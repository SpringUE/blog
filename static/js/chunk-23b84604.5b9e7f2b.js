(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-23b84604"],{"59da":function(e,n,t){"use strict";t.r(n);var l=t("f2bf");const c={class:"blog-doc-component"},a=Object(l["n"])("h1",null,"吐槽出入react踩过的“坑”",-1),r=Object(l["n"])("h2",{id:"yi-xuan-ran-pian",tabindex:"-1"},[Object(l["n"])("a",{class:"header-anchor",href:"#yi-xuan-ran-pian"},"¶"),Object(l["p"])(" 一、渲染篇：")],-1),s=Object(l["n"])("p",null,[Object(l["n"])("strong",null,"1. 第一个要说说“内联样式”:")],-1),p=Object(l["n"])("p",null,"场景：在JSX的render中写内联样式，如",-1),o=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-html"},'<div style={"marginTop:10px"}></div>\n')],-1),u=Object(l["n"])("p",null,"报错：warning：Style prop value must be an object  react/style-prop-object",-1),b=Object(l["n"])("p",null,"原因：在React框架的JSX编码格式要求，style必须是一个对象",-1),i=Object(l["n"])("p",null,"解决：",-1),d=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},'style={{"marginTop:10px"}}\n')],-1),j=Object(l["n"])("p",null,[Object(l["n"])("strong",null,"2.遍历数组元素：")],-1),O=Object(l["n"])("p",null,"场景：",-1),g=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"const address = ['北京', '杭州', '深圳', '上海'];\n\naddress.map((item) => {\nreturn (\n<ul class=\"items\">\n<li class=\"item\">{item}</li>\n</ul>\n)\n});\n")],-1),h=Object(l["n"])("p",null,[Object(l["p"])('报错：Warning:Each child in an array or iterator should have a unique "key" prop. Check the render method of '),Object(l["n"])("code",null,"NavBlock")],-1),m=Object(l["n"])("p",null,"原因：在React中数组遍历返回元素或组件时需加上key属性作为唯一标识",-1),v=Object(l["n"])("p",null,"解决：",-1),f=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},'address.map((item, index) => {\nreturn (\n<ul class="items">\n<li class="item" key={index}>{item}</li>\n</ul>\n)\n});\n')],-1),y=Object(l["n"])("p",null,[Object(l["n"])("strong",null,'3."根元素"：')],-1),_=Object(l["n"])("p",null,"场景：",-1),x=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"render(){\n&nbsp; return (\n<div></div>\n<div></div>\n&nbsp; )\n}\n")],-1),q=Object(l["n"])("p",null,"报错：Adjacent JSX elements must be wrapped in an enclosing tag",-1),w=Object(l["n"])("p",null,'原因：render()函数中返回的所有元素需要包裹在一个"根"元素里面',-1),k=Object(l["n"])("p",null,"解决：",-1),S=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},'return (\n<div class="some">\n<div></div>\n<div></div>\n</div>\n)\n')],-1),R=Object(l["n"])("p",null,[Object(l["n"])("strong",null,"4. “return同行”问题:")],-1),W=Object(l["n"])("p",null,"场景：",-1),J=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},'return &nbsp;<div class="some">\n<p>some</p>\n</div>\n')],-1),H=Object(l["n"])("p",null,"原因：return语句和返回元素不在同一行会被解析器视为返回null导致错误（注意：如果没有使用()的情况）",-1),M=Object(l["n"])("p",null,"解决：",-1),U=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},'return (\n<div class="some">\n<p>some</p>\n</div>\n)\n')],-1),C=Object(l["n"])("p",null,[Object(l["n"])("strong",null,"5. htmlFor问题:")],-1),D=Object(l["n"])("p",null,"原因：标签里用到的for要写成htmlFor，因为for已经成了关键字。",-1),E=Object(l["n"])("p",null,"解决：for要写成htmlFor",-1),F=Object(l["n"])("p",null,[Object(l["n"])("strong",null,"6. table表格问题:")],-1),T=Object(l["n"])("p",null,"场景：",-1),X=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"return (\n<table>\n<tr>\n<td></td>\n</tr>\n</table>\n)\n")],-1),L=Object(l["o"])('<p>报错：Warning: validateDOMNesting(...): &lt;tr&gt; cannot appear as a child of &lt;table&gt;</p><p>原因：在React中&lt;tr&gt;元素不可以作为&lt;table&gt;元素的直接子元素</p><p>解决方法：加入thead/tbody即可。</p><h2 id="er-luo-ji-pian" tabindex="-1"><a class="header-anchor" href="#er-luo-ji-pian">¶</a> 二、逻辑篇：</h2><p><strong>1、setState()是异步的</strong></p><p>this.setState()会调用render方法，但并不会立即改变state的值，state是在render方法中赋值的。所以执行this.setState()后立即获取state的值是不变的。同样的直接赋值state并不会出发更新，因为没有调用render函数。</p><p><strong>2、组件生命周期</strong></p><p>1）在初始化的时候调用： componentWillMount，componentDidMount</p><p>2）在更新的时候才被调用，初始化时不调用： componentWillReceivePorps，shouldComponentUpdate，componentWillUpdata，componentDidUpdate </p><p>3）组件卸载之前，加在dom元素上的监听事件，和定时器需要手动清除，因为这些并不在react的控制范围内，必须手动清除。 指的是在this.refs.xxx这种真实dom上addEventListener这样添加的监听事件，在组件卸载的时候要手动清除(removeEventListener)，react组件上的onClick这种不用管，react帮我们处理好了</p><p>4）componentWillUpdate中可以直接改变state的值，而不能用setState。</p><p><strong>3、reducer必须返回一个新的对象才能出发组件的更新</strong></p><p>因为在connect函数中会对新旧两个state进行浅对比，如果state只是值改变但是引用地址没有改变，connect会认为它们相同而不触发更新。</p><p>**4、无论reducer返回的state是否改变，subscribe中注册的所有回调函数都会被触发。</p><p>5、按需加载时如果组件是通过export default 暴露出去，那么require.ensure时必须加上default。**</p><p><strong>6、react的路由:</strong></p><p>hashHistory和browserHistory，hashHistory由hash#控制跳转，一般用于正式线上部署，browserHistory就是普通的地址跳转，一般用于开发阶段。</p><p><strong>7、React组件</strong></p><p>1)React组件命名的首字母必须是大写，这是类命名的规范； 2)class类继承react的component组件，constructor中必须调用super，因为子类必须用super继承component的this，否则实例化的时候会报错；</p>',19);function N(e,n){const t=Object(l["T"])("code-viewer");return Object(l["K"])(),Object(l["m"])("section",c,[a,r,s,p,Object(l["q"])(t,null,{default:Object(l["hb"])(()=>[o]),_:1}),u,b,i,Object(l["q"])(t,null,{default:Object(l["hb"])(()=>[d]),_:1}),j,O,Object(l["q"])(t,null,{default:Object(l["hb"])(()=>[g]),_:1}),h,m,v,Object(l["q"])(t,null,{default:Object(l["hb"])(()=>[f]),_:1}),y,_,Object(l["q"])(t,null,{default:Object(l["hb"])(()=>[x]),_:1}),q,w,k,Object(l["q"])(t,null,{default:Object(l["hb"])(()=>[S]),_:1}),R,W,Object(l["q"])(t,null,{default:Object(l["hb"])(()=>[J]),_:1}),H,M,Object(l["q"])(t,null,{default:Object(l["hb"])(()=>[U]),_:1}),C,D,E,F,T,Object(l["q"])(t,null,{default:Object(l["hb"])(()=>[X]),_:1}),L])}var P=t("b9a6"),A=t.n(P);const B={},K=A()(B,[["render",N]]);n["default"]=K},b9a6:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=(e,n)=>{const t=e.__vccOpts||e;for(const[l,c]of n)t[l]=c;return t}}}]);