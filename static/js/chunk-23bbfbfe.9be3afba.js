(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-23bbfbfe"],{1863:function(e,t,c){"use strict";c.r(t);var a=c("f2bf");const r={class:"blog-doc-component"},n=Object(a["createElementVNode"])("h1",null,"各种场景下的Git管理方法",-1),l=Object(a["createElementVNode"])("p",null,"本文着重列举开发过程中自己遇到过的各种场景以及用法，不再阐述Git的基础",-1),i=Object(a["createElementVNode"])("h2",{id:"ji-ben-cao-zuo",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#ji-ben-cao-zuo"},"¶"),Object(a["createTextVNode"])(" 基本操作")],-1),o=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-shell"},'git add .\ngit commit -m "修改备注"\ngit push -u origin main\n')],-1),s=Object(a["createElementVNode"])("h2",{id:"1.ben-di-guan-lian-yuan-cheng-cang-ku",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#1.ben-di-guan-lian-yuan-cheng-cang-ku"},"¶"),Object(a["createTextVNode"])(" 1.本地关联远程仓库")],-1),d=Object(a["createElementVNode"])("p",null,"在本地已经建立仓库，或者已有多次提交，后来需要提交到远程的仓库，这时候就需要把本地与远程库存关联",-1),m=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-shell"},"git remote add origin https://github.com/SpringUE/xform.git\n\n# 关联操作\ngit remote rm name  # 删除远程仓库\ngit remote rename old_name new_name  # 修改仓库名\n")],-1),h=Object(a["createStaticVNode"])('<h2 id="2.duo-huan-jing-ce-lue" tabindex="-1"><a class="header-anchor" href="#2.duo-huan-jing-ce-lue">¶</a> 2.多环境策略</h2><p>大型项目中，多人协同，快速更新迭代，无法避免多特性同时开发，甚至边开发边修复UAT问题、生成问题。<br> 以develop分支做基线，SIT环境使用，UAT环境使用release分支，生产环境使用master</p><ul><li>合入顺序: develop --&gt; release --&gt; master</li><li>修改生产问题同步推送到release &amp;&amp; develop</li><li>修改UAT问题同步推送到develop</li></ul><div class="warning"><p>Tips 修改UAT、生产问题务必同步向前推送到develop，否则修改的越多最终越难合并，多人协同特别注意</p></div><h2 id="3.ben-di-duo-fen-zhi-kai-fa-diao-shi" tabindex="-1"><a class="header-anchor" href="#3.ben-di-duo-fen-zhi-kai-fa-diao-shi">¶</a> 3.本地多分支开发调试</h2><p>现代项目几乎大多数后端都微服务化，前后端分模块分人联调，这些都是常见的事。<br> 管理多套完整代码，主要用到stash命令的功能</p><p>stash 命令能够将还未 commit 的代码存起来，让你的工作目录变得干净。</p>',7),p=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-shell"},'git stash # 保存当前未commit的代码\ngit stash save "备注的内容" # 保存当前未commit的代码并添加备注\ngit stash list # 列出stash的所有记录\ngit stash clear # 删除stash的所有记录\ngit stash apply # 应用最近一次的stash\ngit stash pop # 应用最近一次的stash，随后删除该记录\ngit stash drop # 删除最近的一次stash\n\n# 当有多条 stash，可以指定操作stash，首先使用stash list 列出所有记录：\n$ git stash list\nstash@{0}: WIP on ...\nstash@{1}: WIP on ...\nstash@{2}: On ...\n\n# 应用第二条记录：\n$ git stash apply stash@{1}\n\n# pop，drop 同理。\n')],-1),b=Object(a["createElementVNode"])("p",null,"不同的环境、不同的模块接口人，在前端联调的时候需要临时性设置联调参数，例如：环境地址、微服务代理地址等。 这些代码仅在本地某个分支联调过程中临时存在，并不会提交推送，则使用stash可保存个联调场景需要的临时代码，切换时将这部分代码暂存起来，下次切换回来后换出即可。",-1),u=Object(a["createElementVNode"])("h2",{id:"4.che-hui-ti-jiao",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#4.che-hui-ti-jiao"},"¶"),Object(a["createTextVNode"])(" 4.撤回提交")],-1),j=Object(a["createElementVNode"])("p",null,"经常因为操作太快导致误提交，reset --soft命令，它能让 commit 记录强制回溯到某一个节点，修改的内容都回到暂存区。",-1),O=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-shell"},"# 恢复最近一次commit\ngit reset --soft HEAD^\n\n# reset 到某一次commit\ngit reset --soft 5b62bybx2wxci1x7422hdhh9my374tf6hj9ynx\n")],-1),g=Object(a["createStaticVNode"])('<div class="warning"><p>Tips 以上说的是还未 push 的commit。对于已经 push 的 commit，也可以使用该命令，不过再次 push 时，由于远程分支和本地分支有差异，需要强制推送 git push -f 来覆盖被 reset 的 commit。<br> 值得注意的是，在 reset --soft 指定 commit 号时，会将该 commit 到最近一次 commit 的所有修改内容全部恢复，而不是只针对该 commit 举个栗子： commit 记录有 c、b、a reset 到 a 此时的 HEAD 到了 a，而 b、c 的修改内容都回到了暂存区</p></div><p>reset --soft 总的来说是给你有可以再次修改重新提交的机会，保持干净的 commit 记录。</p><h2 id="5.tiao-jian-ti-jiao-de-nei-rong" tabindex="-1"><a class="header-anchor" href="#5.tiao-jian-ti-jiao-de-nei-rong">¶</a> 5.挑拣提交的内容</h2><p>场景1：经常在改sit环境BUG问题单的时候，uat同时发现了某个同样的问题，然而因为环境之间不同步，这时候就需要把某个或某些 commit 挑拣出来，单独合入release_uat分支</p><p>场景2：有时候一大波需求开发结束准备上uat，但由于某些原因导致某些特性不能及时上线，则把N多个特性 commit 中抽取部分commit 到新的分支</p><h3 id="cherry-pick-tiao-jian-dai-ma" tabindex="-1"><a class="header-anchor" href="#cherry-pick-tiao-jian-dai-ma">¶</a> cherry-pick 挑拣代码</h3><p>挑拣多个提交应用到当前分支：</p>',7),N=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-shell"},"git cherry-pick commit1 commit2\n")],-1),V=Object(a["createElementVNode"])("p",null,"挑拣多个连续的commit，也可区间复制：",-1),E=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-shell"},"git cherry-pick commit1^..commitN\n")],-1),f=Object(a["createElementVNode"])("p",null,"上面的命令将 commit1 到 commitN 这个区间的 commit 都应用到当前分支（包含commit1、commitN），commit1 是最早的提交。",-1),x=Object(a["createElementVNode"])("h3",{id:"cherry-pick-dai-ma-chong-tu",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#cherry-pick-dai-ma-chong-tu"},"¶"),Object(a["createTextVNode"])(" cherry-pick 代码冲突")],-1),y=Object(a["createElementVNode"])("p",null,"在 cherry-pick 挑拣多个commit时，可能会遇到代码冲突，这时 cherry-pick 会停下来，让用户决定如何继续操作。下面看看怎么解决这种场景。",-1),k=Object(a["createElementVNode"])("p",null,"还是 feature 分支，现在需要把 c、d、e 都复制到 release 分支上。先把起点c和终点e的 commitHash 记下来。",-1),v=Object(a["createElementVNode"])("p",null,"切到 release 分支，使用区间的 cherry-pick，可以看到 c 被成功复制，当进行到 d 时，发现代码冲突，cherry-pick 中断了。这时需要解决代码冲突，重新提交到暂存区。",-1),w=Object(a["createElementVNode"])("p",null,"然后使用 cherry-pick --continue 让 cherry-pick 继续进行下去。最后 e 也被复制进来，整个流程就完成了。 以上是完整的流程，但有时候可能需要在代码冲突后，放弃或者退出流程：",-1),_=Object(a["createElementVNode"])("h3",{id:"fang-qi-cherry-pick",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#fang-qi-cherry-pick"},"¶"),Object(a["createTextVNode"])(" 放弃 cherry-pick")],-1),T=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-shell"},"gits cherry-pick --abort\n")],-1),C=Object(a["createElementVNode"])("p",null,"取消操作，就像什么都没发生过。",-1),H=Object(a["createElementVNode"])("h3",{id:"tui-chu-cherry-pick",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#tui-chu-cherry-pick"},"¶"),Object(a["createTextVNode"])(" 退出 cherry-pick：")],-1),z=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-shell"},"git cherry-pick --quit\n")],-1),A=Object(a["createElementVNode"])("p",null,"不回到操作前的样子。即保留已经 cherry-pick 成功的 commit，并退出 cherry-pick 流程。",-1),U=Object(a["createElementVNode"])("h2",{id:"6.huan-yuan-pu-tong-ti-jiao",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#6.huan-yuan-pu-tong-ti-jiao"},"¶"),Object(a["createTextVNode"])(" 6.还原普通提交")],-1),S=Object(a["createElementVNode"])("p",null,[Object(a["createTextVNode"])("revert 给定一个或多个现有提交，恢复相关提交引入的更改，并记录一些这些更改的新提交。这就要求你的工作树是干净的（没有来自头部的修改）。"),Object(a["createElementVNode"])("br"),Object(a["createTextVNode"])(" 将现有的提交还原，恢复提交的内容，并生成一条还原记录。")],-1),q=Object(a["createElementVNode"])("p",null,"现在 master 记录如下：",-1),G=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-shell"},"git revert 5b62bybx2wxci1x7422hdhh9my374tf6hj9ynx\n")],-1),B=Object(a["createElementVNode"])("p",null,"revert 掉自己提交的 commit。",-1),I=Object(a["createElementVNode"])("p",null,"因为 revert 会生成一条新的提交记录，这时会让你编辑提交信息，编辑完后 :wq 保存退出就好了。",-1),P=Object(a["createElementVNode"])("p",null,"再来看下最新的 log，生成了一条 revert 记录，虽然自己之前的提交记录还是会保留着，但你修改的代码内容已经被撤回了。 revert 合并提交 在 git 的 commit 记录里，还有一种类型是合并提交，想要 revert 合并提交，使用上会有些不一样。",-1),D=Object(a["createElementVNode"])("p",null,"现在的 master 分支里多了条合并提交。",-1),J=Object(a["createElementVNode"])("p",null,"使用刚刚同样的 revert 方法，会发现命令行报错了。 为什么会这样？在官方文档中有解释。",-1),W=Object(a["createElementVNode"])("p",null,"通常无法 revert 合并，因为您不知道合并的哪一侧应被视为主线。此选项指定主线的父编号（从1开始），并允许 revert 反转相对于指定父编号的更改",-1),$=Object(a["createElementVNode"])("p",null,'我的理解是因为合并提交是两条分支的交集节点，而 git 不知道需要撤销的哪一条分支，需要添加参数 -m 指定主线分支，保留主线分支的代码，另一条则被撤销。 -m 后面要跟一个 parent number 标识出"主线"，一般使用 1 保留主分支代码。',-1),M=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-shell"},"git revert -m 1 <commitHash>\n")],-1),F=Object(a["createStaticVNode"])('<p>revert 合并提交后，再次合并分支会失效 还是上面的场景，在 master 分支 revert 合并提交后，然后切到 feature 分支修复好 bug，再合并到 master 分支时，会发现之前被 revert 的修改内容没有重新合并进来。 因为使用 revert 后， feature 分支的 commit 还是会保留在 master 分支的记录中，当你再次合并进去时，git 判断有相同的 commitHash，就忽略了相关 commit 修改的内容。 这时就需要 revert 掉之前 revert 的合并提交，有点拗口，接下来看操作吧。</p><p>现在 master 的记录是这样的。</p><p>再次使用 revert，之前被 revert 的修改内容就又回来了。</p><h2 id="7.guan-li-chong-lu-zhong-ji-lu-de-xin-xi" tabindex="-1"><a class="header-anchor" href="#7.guan-li-chong-lu-zhong-ji-lu-de-xin-xi">¶</a> 7.管理重录中记录的信息</h2><p>官方文档描述： 此命令管理重录中记录的信息。</p><p>如果说 reset --soft 是后悔药，那 reflog 就是强力后悔药。它记录了所有的 commit 操作记录，便于错误操作后找回记录。 应用场景 应用场景：某天你眼花，发现自己在其他人分支提交了代码还推到远程分支，这时因为分支只有你的最新提交，就想着使用 reset --hard，结果紧张不小心记错了 commitHash，reset 过头，把同事的 commit 搞没了。没办法，reset --hard 是强制回退的，找不到 commitHash 了，只能让同事从本地分支再推一次（同事瞬间拳头就硬了，怎么又是你）。于是，你的技术形象又一落千丈。 命令使用</p><p>分支记录如上，想要 reset 到 b。</p><p>误操作 reset 过头，b 没了，最新的只剩下 a。</p><p>这时用 git reflog 查看历史记录，把错误提交的那次 commitHash 记下。</p><p>再次 reset 回去，就会发现 b 回来了。 设置 Git 短命令 对我这种喜欢敲命令而不用图形化工具的爱好者来说，设置短命令可以很好的提高效率。下面介绍两种设置短命令的方式。 方式一 git config --global alias.ps push</p><p>方式二 打开全局配置文件 vim ~/.gitconfig</p><p>写入内容 [alias] co = checkout ps = push pl = pull mer = merge --no-ff cp = cherry-pick</p><p>使用</p>',13),K=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-shell"},"# 等同于 git cherry-pick <commitHash>\ngit cp <commitHash>\n")],-1);function L(e,t){const c=Object(a["resolveComponent"])("code-viewer");return Object(a["openBlock"])(),Object(a["createElementBlock"])("section",r,[n,l,i,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[o]),_:1}),s,d,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[m]),_:1}),h,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[p]),_:1}),b,u,j,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[O]),_:1}),g,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[N]),_:1}),V,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[E]),_:1}),f,x,y,k,v,w,_,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[T]),_:1}),C,H,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[z]),_:1}),A,U,S,q,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[G]),_:1}),B,I,P,D,J,W,$,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[M]),_:1}),F,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[K]),_:1})])}var Q=c("b9a6"),R=c.n(Q);const X={},Y=R()(X,[["render",L]]);t["default"]=Y},b9a6:function(e,t,c){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=(e,t)=>{const c=e.__vccOpts||e;for(const[a,r]of t)c[a]=r;return c}}}]);