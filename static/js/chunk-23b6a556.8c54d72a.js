(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-23b6a556"],{7472:function(e,n,a){"use strict";a.r(n);var l=a("f2bf");const c={class:"blog-doc-component"},t=Object(l["o"])('<h1>Webpack打包原理浅析</h1><p>**简介：**对于很多前端小伙伴来说，webpack绝对是不陌生的，但是如果想要较为深入地去理解其中的原理，其实并不简单。因此，本文就目前前端最为热门的打包工具webpack，对其作用、打包原理及优化进行一定程度的探讨，分析过程中有部分自己的见解，同时也引用了部分外部的资料，如有错误，欢迎指出。</p><h2 id="1-wei-he-shi-yong-webpack" tabindex="-1"><a class="header-anchor" href="#1-wei-he-shi-yong-webpack">¶</a> 1、为何使用Webpack？</h2><p>当出现一些新鲜事物的时候，我们总会去思考这个新鲜事物出现的必要性，webpack的出现也是一样，因此webpack出现之前，开发过程中实际存在着非常多的困难： 引用一些脚本来存放每个功能，加载太多脚本会导致网络瓶颈？ IIFE 使用方式可以将所有项目文件拼接在一起，但是却使构建结果的优化变得更加困难？ CommonJS 问世并引入了 require 机制，但浏览器不支持模块？等等... 因而就此看来，webpack的问世也变得顺其自然了，当然它也很好地解决了上面所存在得困难： a: 模块化开发，强大的构建优化能力（import，require） b: 预处理，方便使用多种格式资源（Less，Sass，ES6，TypeScrip等） c: 主流框架脚手架支持，大大加快开发效率（Vue，React，Angular） d: 良好以及众多的社区支持（资源丰富，降低学习成本）</p><h2 id="2-webpackshi-shi-me" tabindex="-1"><a class="header-anchor" href="#2-webpackshi-shi-me">¶</a> 2、Webpack是什么？</h2><p>对于webpack的定义其实可以归结为js模块打包器，在 webpack 中，一切皆是模块，一个文件就是一个模块(module)，它能够根据指定的入口（entry），通过模块间的依赖关系，递归地构建出一张依赖关系图（dependency graph）。由于webpack只理解 JavaScript 和 JSON 文件，过程中可以通过配置指定的加载器（loader）对相应文件进行转换，也可以通过配置指定的插件（plugins）对上下文进行优化输出（output）为代码块（chunk）如下图（引用的网图）： <img src="https://ucc.alicdn.com/pic/developer-ecology/8e7f6092065d4fb38a179ee188d51b7c.png" alt="538c4af0d21e375d6d252d38cbb8a993.png" title="538c4af0d21e375d6d252d38cbb8a993.png"></p><h2 id="3-webpack.config.jschang-yong-zhu-yao-he-xin-pei-zhi-gai-nian" tabindex="-1"><a class="header-anchor" href="#3-webpack.config.jschang-yong-zhu-yao-he-xin-pei-zhi-gai-nian">¶</a> 3、webpack.config.js常用主要核心配置概念</h2><p>a: 模式mode 通过告诉webpack使用相应模式，存在两种配置方式 通过配置文件：</p>',8),s=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"module.exports = {\n  mode: 'production', // development\n}\n\n")],-1),o=Object(l["n"])("p",null,"通过命令行传参：",-1),r=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"webpack --mode=production\n\n")],-1),u=Object(l["n"])("p",null,"然后代码中：",-1),p=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"if(process.env.NODE_ENV === 'development'){\n//开发环境处理逻辑\n}else{\n//生产环境处理逻辑\n}\n\n")],-1),d=Object(l["n"])("p",null,"b: 入口entry 单入口：",-1),b=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"module.exports = {\n    entry: './src/main.js',\n}\n\n")],-1),i=Object(l["n"])("p",null,"多入口：",-1),j=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"module.exports = {\n  entry: {\n    foo: './src/main.js',\n    bar: './src/foo.js',\n    com: './src/bar.js'\n  }\n}\n\n")],-1),h=Object(l["n"])("p",null,"c: 出口output 告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值是 ./dist: 单出口：",-1),g=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"const path = require('path')\nmodule.exports = {\n  output: {\n      filename: 'main.js',\n      path: path.resolve(__dirname, 'dist')\n  }\n}\n\n")],-1),m=Object(l["n"])("p",null,"多出口：",-1),O=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"const path = require('path')\nmodule.exports = {\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  }\n}\n\n")],-1),f=Object(l["n"])("p",null,"d: 模块module 在webpack中，一切皆是模块，而一个文件就是一个模块。 e: 加载器loader 由于webpack本身只能理解JavaScript语法，因此只能对js文件进行直接的文件合并、压缩处理。但是实际项目中会用到很多类型的文件，如 css、less、jpg、jsx、vue 等等类型的文件，webpack本身是处理不了它们的，这个时候就要借助于各种loader。 loader 的作用就是将各种类型的文件转换成 webpack 能够处理的模块，例如项目中使用了 less 语法，就需要使用 less-loader 去将其转译为 css，然后通过 css-loader 去加载 css 文件，处理后交给 style-loader，最后把资源路径写入到 html 中的 style 标签内生效。",-1),k=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"module: {\n    rules: [{\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader', 'less-loader']\n    }]\n},\n\n")],-1),_=Object(l["n"])("p",null,"需要注意的是由于 loader 是从右往左执行的，一个 loader 处理完的结果会交给下一个 loader 继续处理，就像一条工厂流水线一样，所以加载器数组存在一定的次序。 此外特别需要知道的是，有一个非常重要的 loader，那就是 babel-loader，其可以将es6语法转换成能普遍被浏览器所执行的es5。 f: 插件plugin 插件是用来处理各种任务的，比如代码的压缩，打包优化，等等。比如自动生成 html 文件的插件",-1),w=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"const HtmlWebpackPlugin = require('html-webpack-plugin'); \nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n        template: './src/index.html'\n    })\n  ]\n};\n\n")],-1),v=Object(l["n"])("p",null,"g: 代码块chunk 代码块，一个chunk由多个模块组合而成，用于代码合并和分割。 h: 源代码映射source-map source map 是一种映射关系，当程序出问题时，我们想要从打包后的代码中去排查问题时比较困难的。这个时候我们就要借助于源代码去排查。其中包含有好几种配置方式：",-1),x=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"module.exports = {\n  devtool: 'source-map'，//inline-source-map, inline-cheap-source-map, inline-cheap-module-source-map, eval\n}\n\n")],-1),q=Object(l["n"])("p",null,"source-map：打包后会生成 map 格式的文件，里面包含映射关系的代码 inline-source-map：打包后不会生成 map 格式的文件，包含映射关系的代码会放在打包后的代码中 inline-cheap-source-map：cheap有两种作用：一是将错误只定位到行，不定位到列。二是映射业务代码，不映射loader和第三方库等。会提升打包构建的速度。 inline-cheap-module-source-map：module会映射loader和第三方库 eval：用 eval 的方式生成映射关系代码，效率和性能最佳。但是当代码复杂时，提示信息可能不精确 因此实际开发中往往推荐以下两种配置方式 开发环境： devtool: 'cheap-module-eval-source-map', 生产环境 devtool: 'cheap-module-source-map',",-1),y=Object(l["n"])("h2",{id:"4-da-bao-liu-cheng-ji-ben-yuan-li-qian-xi",tabindex:"-1"},[Object(l["n"])("a",{class:"header-anchor",href:"#4-da-bao-liu-cheng-ji-ben-yuan-li-qian-xi"},"¶"),Object(l["p"])(" 4、打包流程基本原理浅析")],-1),P=Object(l["n"])("p",null,[Object(l["p"])("以下的原理解析是基于webpack4的自我理解，根据简单的demo目标打包生成物为切入口进行分析，进而去理解其内部执行流程，其大致工作流程如下图（引用的网图）所示： "),Object(l["n"])("img",{src:"https://ucc.alicdn.com/pic/developer-ecology/50345c2dbf6d4ac0a337ca1e12b9c942.jpg",alt:"list.jpg",title:"list.jpg"})],-1),S=Object(l["n"])("p",null,"a: 打包后产物(简略部分)",-1),I=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"(function (modules) {\n    //内部执行流程\n    ...\n})({\n    //外部模块id对象\n    './main.js': (function (module, exports, __webpack_require__) {}),\n    './foo.js': (function (module, exports, __webpack_require__) {}),\n    ...\n})\n\n")],-1),z=Object(l["n"])("p",null,"webpack 打包完输出的 bundle.js 大致就是上面这个架子。可以看出它本质就是一个自执行的函数，参数是 一个Object 对象，而对象的key 就是我们项目中的各个模块的js 文件名称。value 是一个 function，模块中的代码都会被解析后放在这个 function 内。 这些 function 会接收 module 和 exports 做为参数，这也是为什么我们在模块中使用 CommonJs 语法（也就是 modules.exports = {} 或者 直接 exports = {}），浏览器能够识别的原因。我们在模块的最后其实使用 module.exports = {}，其实就是把模块的内容放进了 exports 对象里而已。 b: 传参数组（模块数组）的形成 那上面这个传递给匿名函数的数组又是怎么形成的呢？过程大致如下： webpack 中有这么一个 Complier 类，它首先会读取 webpack.config.js 中的内容 然后通过 @babel/parse，从入口文件 entry 来构建一颗抽象语法树 AST 然后通过 @babel/traverse，根据抽象语法树得出入口文件的依赖模块 然后通过 @babel/core 和 @babel/preset-env，根据抽象语法树解析出入口文件的代码。这一步已经把 ES6 或更高版本的 js 转换了，然后循环递归入口文件的依赖，构建出一张依赖关系图这就是我们上面用到的数组了。 c: 匿名函数内部",-1),A=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},'var installedModules = {};\nfunction __webpack_require__(moduleId) {\n    if(installedModules[moduleId]) {\n        return installedModules[moduleId].exports;\n    }\n    var module = installedModules[moduleId] = {\n        i: moduleId,\n        l: false,\n        exports: {}\n    };       \n    modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);\n    module.l = true;\n    return module.exports;\n}\nreturn __webpack_require__(__webpack_require__.s = "./src/main.js");\n\n')],-1),C=Object(l["o"])('<p>可以看到自执行函数里面定义了一个 <strong>webpack_require</strong> 函数，是用来装载模块的。它的入参是模块的唯一标识，从a中我们可以看到这个唯一标识就是模块的文件名称。 其中装载后的变量会放在变量 installedModules 里面，防止同一模块重复装载。 而什么是装载？装载就是执行传进来的 modules 中的一个个函数，也就是会执行我们所写的业务模块里面的代码，把 exports 传进去，然后我们会这样 module.exports = {...}，把内容给放进去。简而言之，装载就是把模块代码装进 exports 对象。<strong>webpack_require</strong> 函数最终会返回这个 exports。 我们模块中的依赖也会调用这个 <strong>webpack_require</strong>，比如 main.js 引入了 foo.js，那么 main 函数内部会有这么一句 const foo = <strong>webpack_require</strong>(/*! ./foo */ &quot;./foo.js&quot;); 这样我们就可以在 main 中获取并使用到 foo 所提供的功能了（其实就是在用 foo.js 中最后赋值的那个 exports） d：流程细分图（引用的网图）如下： <img src="https://ucc.alicdn.com/pic/developer-ecology/f2c9cd2150204f789c7a8473baf336c4.jpg" alt="20200324205715661.jpg" title="20200324205715661.jpg"> e：更详细通俗易懂的demo可以查阅此文章： <a href="https://blog.csdn.net/haodawang/article/details/77126686">https://blog.csdn.net/haodawang/article/details/77126686</a></p><h2 id="5-chang-jian-you-hua-gou-jian" tabindex="-1"><a class="header-anchor" href="#5-chang-jian-you-hua-gou-jian">¶</a> 5、常见优化构建</h2><p>a: 优化loader配置 上面章节我们可以知道loader作用是对相应文件进行转换，所以我们可以考虑通过减少loader作用范围，大大缩短构建时间。例如Babel，由于Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。因此我们直接指定哪些文件不通过loader处理,或者指定哪些文件通过loader处理：</p>',3),H=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"const path = require('path')\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        // js 文件才使用 babel\n        test: /\\.js$/,\n        use: ['babel-loader'],\n        // 只处理src文件夹下面的文件\n        include: path.resolve('src'),\n        // 不处理node_modules下面的文件，node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。\n        exclude: /node_modules/\n      }\n    ]\n  }\n}\n\n")],-1),J=Object(l["n"])("p",null,"另外，对于babel-loader，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间。",-1),W=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"module.exports = {\n  loader: 'babel-loader?cacheDirectory=true'\n}\n")],-1),B=Object(l["n"])("p",null,"b: 使用多线程处理打包 由于node是单线程运行的，所以 webpack 在打包的过程中也是单线程的，特别是在执行 loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。那么我们可以使用一些方法将 loader 的同步执行转换为并行，这样就能充分利用系统资源来提高打包速度了。 例如happypack，如其包名，快乐的打包。就是能够让Webpack把打包任务分解给多个子线程去并发的执行，子线程处理完后再把结果发送给主线程：",-1),M=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"const HappyPack = require('happypack');\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        //把 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例\n        use: ['happypack/loader?id=babel'],\n        exclude: path.resolve(__dirname, 'node_modules'),\n      },\n      {\n        test: /\\.css$/,\n        // 把 .css 文件的处理转交给 id 为 css 的 HappyPack 实例\n        use: ['happypack/loader?id=css']\n      }\n    ]\n  },\n  plugins: [\n    new HappyPack({\n      id: 'js', //ID是标识符的意思，ID用来代理当前的happypack是用来处理一类特定的文件的\n      threads: 2, //你要开启多少个子进程去处理这一类型的文件\n      loaders: [ 'babel-loader' ]\n    }),\n    new HappyPack({\n      id: 'css',\n      threads: 2,\n      loaders: [ 'style-loader', 'css-loader' ]\n    })\n  ],\n}\n")],-1),$=Object(l["n"])("p",null,"c: module.noParse 属性 module.noParse 属性，可以用于配置那些模块文件的内容不需要进行解析（即无依赖） 的第三方大型类库（例如jquery,lodash）等，使用该属性让 Webpack不扫描该文件，以提高整体的构建速度。",-1),E=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"module.exports = {\n    module: {\n      noParse: /jquery|lodash/, // 正则\n      noParse: function(content) {\n        return /jquery|lodash/.test(content)\n      }\n    }\n}\n")],-1),N=Object(l["n"])("p",null,"d: 打包文件分析工具 webpack-bundle-analyzer插件的功能是可以生成代码分析报告，帮助提升代码质量和网站性能。",-1),T=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin\nmodule.exports={\n  plugins: [\n     new BundleAnalyzerPlugin({\n        generateStatsFile: true, // 是否生成stats.json文件\n     })  \n  ]\n}\n")],-1),D=Object(l["n"])("p",null,"e: 对图片进行压缩和优化 image-webpack-loader这个loder可以帮助我们对打包后的图片进行压缩和优化，例如降低图片分辨率，压缩图片体积等。",-1),F=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"module.exports ={\n    module: {\n        rules: [\n            {\n              test: /\\.(png|gif|jpe?g|svg)$/i,\n              exclude:[path.resolve(process.cwd(), 'src/assets/css')],\n              use: [\n                {\n                   loader: 'url-loader',\n                   options: {\n                   limit: 1024,// 图片限制\n                   name: '[hash:8].[ext]',\n                   useRelativePath: false,\n                   outputPath: function(fileName){\n                   return 'assets/images/'+fileName\n                    }\n                }\n            },\n            {\n              loader:'image-webpack-loader'\n            }\n        ]\n    }\n};\n")],-1),R=Object(l["n"])("p",null,"f： 删除无用的CSS样式 久远且疏于维护的项目可能会存在一些CSS样式被迭代废弃，可以将其去除掉，此时就可以使用purgecss-webpack-plugin插件，该插件可以去除未使用的CSS，一般与 glob、glob-all 一起配合使用。 注意：此插件必须和CSS代码抽离插件mini-css-extract-plugin配合使用。",-1),V=Object(l["n"])("pre",null,[Object(l["n"])("code",{class:"language-javascript"},"const glob = require('glob');\nconst PurgecssPlugin = require('purgecss-webpack-plugin');\nmodule.exports ={\n    plugins: [\n        // 需要配合mini-css-extract-plugin插件\n        new PurgecssPlugin({\n            paths: glob.sync(`${path.join(__dirname, 'src')}/**/*`, \n                  {nodir: true}), // 不匹配目录，只匹配文件\n            })\n        }),\n    ]\n};\n")],-1),K=Object(l["n"])("h2",{id:"can-kao",tabindex:"-1"},[Object(l["n"])("a",{class:"header-anchor",href:"#can-kao"},"¶"),Object(l["p"])(" 参考：")],-1),L=Object(l["n"])("p",null,[Object(l["n"])("a",{href:"https://webpack.docschina.org/concepts/"},"https://webpack.docschina.org/concepts/"),Object(l["n"])("br"),Object(l["n"])("a",{href:"https://survivejs.com/webpack/developing/getting-started/"},"https://survivejs.com/webpack/developing/getting-started/")],-1);function G(e,n){const a=Object(l["T"])("code-viewer");return Object(l["K"])(),Object(l["m"])("section",c,[t,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[s]),_:1}),o,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[r]),_:1}),u,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[p]),_:1}),d,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[b]),_:1}),i,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[j]),_:1}),h,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[g]),_:1}),m,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[O]),_:1}),f,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[k]),_:1}),_,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[w]),_:1}),v,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[x]),_:1}),q,y,P,S,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[I]),_:1}),z,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[A]),_:1}),C,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[H]),_:1}),J,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[W]),_:1}),B,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[M]),_:1}),$,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[E]),_:1}),N,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[T]),_:1}),D,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[F]),_:1}),R,Object(l["q"])(a,null,{default:Object(l["hb"])(()=>[V]),_:1}),K,L])}var Q=a("b9a6"),U=a.n(Q);const X={},Y=U()(X,[["render",G]]);n["default"]=Y},b9a6:function(e,n,a){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=(e,n)=>{const a=e.__vccOpts||e;for(const[l,c]of n)a[l]=c;return a}}}]);