(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-7cc724b0"],{1389:function(e,t,c){"use strict";c.r(t);var a=c("f2bf"),p=c("569a"),i=c.n(p),r=c("a1e4"),l=c.n(r),o=c("e192"),m=c.n(o);const n={class:"blog-doc-component"},b=Object(a["createElementVNode"])("h1",null,"矩形树图treeMap的简单实现",-1),d=Object(a["createElementVNode"])("h2",{id:"an-li",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#an-li"},"¶"),Object(a["createTextVNode"])(" 案例")],-1),u=Object(a["createElementVNode"])("h4",{id:"webpack-bundle-analyzer-plugin",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#webpack-bundle-analyzer-plugin"},"¶"),Object(a["createTextVNode"])(" Webpack Bundle Analyzer Plugin")],-1),s=Object(a["createElementVNode"])("img",{src:i.a,alt:"Bundle Analyzer Plugin"},null,-1),f=Object(a["createElementVNode"])("p",null,"十分惊艳！webpack-bundle-analyzer是一个webpack 插件，只需要简单的配置就可以在 webpack 运行结束后获得 treemap 形态的模块分布统计图，用户可以仔细对比 treemap 内容推断是否包含重复模块、不必要的模块等场景",-1),h=Object(a["createElementVNode"])("h4",{id:"g2plotshou-ji-xiao-liang-zhan-bi-tu-mo-ni-shu-ju",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#g2plotshou-ji-xiao-liang-zhan-bi-tu-mo-ni-shu-ju"},"¶"),Object(a["createTextVNode"])(" G2Plot手机销量占比图(模拟数据)")],-1),j=Object(a["createElementVNode"])("img",{src:l.a,alt:"G2Plot_complex_demo"},null,-1),g=Object(a["createStaticVNode"])('<p>同样十分惊艳，在此图中非常直观、清晰的看出各手机品牌的权重占比，以及品牌下各手机型号的占比</p><h2 id="jian-jie" tabindex="-1"><a class="header-anchor" href="#jian-jie">¶</a> 简介</h2><p>在展示具有层级关系的数据时，除了树状图，还有一种特殊的图形——矩形树图。矩形树图将树状结构转化成了平面矩形，这种结构除了可以展示层级关系外，还很适合展示数据的权重关系。</p><p>本文主要介绍在实现&quot;在同一级别的节点中，按照各自的权重，将坐标系分割成若干矩形块&quot;这一布局功能所用到的算法，以及在 G2 Plot 中如何应用。</p><p>在具体到每一种算法前，我们先来思考一下, 一个理想的矩形树图布局应该有怎么样的特性：</p><ul><li><p>我们希望布局尽可能的接近正方形，因为细长条的形状不利于相互比较其权重大小，也不利于点击下钻等交互。定义纵横比为长边/短边，即纵横比越高，效果越差</p></li><li><p>我们希望树图是有序的，用户可以方便的进行连续阅读</p></li><li><p>我们希望树图尽可能稳定：当输入数据发生变化时，树图应尽快少改变。</p></li></ul><p>接下来，我们从纵横比，有序性，稳定性三个方面出发，了解 G2 Plot 矩形树图的布局方式。</p><div class="tip"><blockquote><p>Tip1：G2 Plot 矩形树图布局算法基于 <a href="https://github.com/xswei/d3-hierarchy">d3-hierarchy</a> 。以下内容同样基于 d3-hierarchy 库。<br> Tip2：用户在 G2Plot 中，可使用 hierarchyConfig 属性，更改预设算法</p></blockquote></div><h2 id="1.-treemapdice-treemapslice-treemapslicedice" tabindex="-1"><a class="header-anchor" href="#1.-treemapdice-treemapslice-treemapslicedice">¶</a> 1. T<strong>reemapDice &amp; TreemapSlice &amp; TreemapSliceDice</strong></h2><p>TreemapDice 算法比较简单，将通过指定 <em>x0</em>, <em>y0</em>, <em>x1</em>, <em>y1</em> 所指定的矩形区域按指定节点的每个子节点的权重水平分割. 子节点按顺序排列即可。</p><p>示意图如下：</p>',11),y=Object(a["createElementVNode"])("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33500ddbfc2d4e21b35123006f3474f9~tplv-k3u1fbpfcp-zoom-1.image",alt:"屏幕快照 2021-02-01 22.21.19.png"},null,-1),O=Object(a["createElementVNode"])("p",null,"依次来评判 TreemapDice 算法",-1),N=Object(a["createElementVNode"])("ul",null,[Object(a["createElementVNode"])("li",null,[Object(a["createElementVNode"])("p",null,"纵横比: 很高，所有的数据均是单向切割，效果很差")]),Object(a["createElementVNode"])("li",null,[Object(a["createElementVNode"])("p",null,"有序性：有序，子节点按顺序排列")]),Object(a["createElementVNode"])("li",null,[Object(a["createElementVNode"])("p",null,"稳定性：稳定。当某个节点权重改变时，由于整体为纵向布局，改变内容较少")])],-1),V=Object(a["createElementVNode"])("p",null,"TreemapSlice 算法类似于 TreemapDice, 区别是进行横向分割",-1),w=Object(a["createElementVNode"])("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/324b2bad6839424f9f6c4212a952e3a3~tplv-k3u1fbpfcp-zoom-1.image",alt:"屏幕快照 2021-02-01 22.25.35.png"},null,-1),k=Object(a["createElementVNode"])("p",null,"无论是TreemapSlice 还是 TreemapDice，他们的纵横比都很差，尤其是在嵌套树图中。TreemapSliceDice 改善了这种做法，即如果指定的节点深度为奇数, 则使用 TreemapSlice 算法; 否则使用 TreemapDice 算法。图示如下。",-1),x=Object(a["createElementVNode"])("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aa0ac9973084d1284e7f0c4b71cdeef~tplv-k3u1fbpfcp-zoom-1.image",alt:"屏幕快照 2021-02-02 10.29.13.png"},null,-1),E=Object(a["createStaticVNode"])('<p>TreemapSliceDice 在层级为 1 的树图中，TreemapSliceDice 的表现和 TreemapSlice 的表现是一致的。而在嵌套树图，改善了其纵横比。</p><p>以上具体代码可参考 <a href="https://github.com/d3/d3-hierarchy/blob/master/src/treemap/slice.js">slice 算法</a>，<a href="https://github.com/d3/d3-hierarchy/blob/master/src/treemap/dice.js">dice 算法</a>，<a href="https://github.com/d3/d3-hierarchy/blob/master/src/treemap/sliceDice.js">sliceDice 算法</a></p><h2 id="2.-treemapbinary" tabindex="-1"><a class="header-anchor" href="#2.-treemapbinary">¶</a> 2. TreemapBinary</h2><p>Treemap Binary 算法递归地将指定的 nodes 划分为一个近似平衡的二叉树，宽矩形进行水平分割和高矩形进行垂直分割。</p><p>基本思路是，每次以 sum/2 为目标，将 node 数组分割为两部分，重复该过程，直至子数组无法再分割。 以数据 [50, 10, 6, 20] 为例:</p>',5),S=Object(a["createElementVNode"])("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c898dc5474f4124a7c3fb61502aaac6~tplv-k3u1fbpfcp-zoom-1.image",alt:"屏幕快照 2021-02-01 18.13.20.png"},null,-1),T=Object(a["createElementVNode"])("p",null,"每次分割的生成的图形为:",-1),_=Object(a["createElementVNode"])("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4cf92bf56504c9fab8cb33bf266c248~tplv-k3u1fbpfcp-zoom-1.image",alt:"屏幕快照 2021-02-01 20.20.17.png"},null,-1),q=Object(a["createTextVNode"])(),v=Object(a["createElementVNode"])("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5009730674214f3a945ef75de42020c1~tplv-k3u1fbpfcp-zoom-1.image",alt:"屏幕快照 2021-02-01 20.19.53.png"},null,-1),z=Object(a["createTextVNode"])(),P=Object(a["createElementVNode"])("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/465aeb14eb6f4295825d06facf4d277e~tplv-k3u1fbpfcp-zoom-1.image",alt:"屏幕快照 2021-02-01 20.19.19.png"},null,-1),D=Object(a["createStaticVNode"])('<p>伪代码如下：</p><p><strong>TreemapBinary</strong><br> 设置可视化空间的初始宽度和高度<br> 设置初始的分割起始位置和结束位置<br> 获取父节点的权重（大部分情况下，即子节点的权重之和）<br> 调用 Partition 函数<br> Partition（节点，位置，宽度，长度）<br> IF(节点已是叶子节点) 根据位置和宽度，长度信息，为节点赋值 目标总值 = 节点权重 / 2； N(当前遍历节点下标) = 0; 左子树 = 空数组; WHILE（左子树 &amp;lt; 目标总值） 左子树加入第 N 个子节点 N + 1； 剩余部分纳入右子树 IF(宽度 &amp;gt; 长度) 左子树宽度 = (左子树权重 / 总权重) * 宽度 右子树宽度 = (右子树权重 / 总权重) * 宽度 Partition（左子树, 位置，左子树宽度，长度） Partition（右子树, 位置，右子树宽度，长度） ELSE 左子树长度 = (左子树权重 / 总权重) * 长度 右子树长度 = (右子树权重 / 总权重) * 长度 Partition（左子树, 位置，宽度，左子树长度） Partition（右子树, 位置，宽度，右子树长度）</p><p>我们来评判 TreemapBinary 算法</p><ul><li><p>纵横比: TreemapBinary 没有刻意保证纵横比，但因为会在子树分割时根据当前纵横比判断是横向或者纵向，所以纵横比效果一般</p></li><li><p>有序性：TreemapBinary 的切割顺序依赖于二叉树的顺序</p></li><li><p>稳定性：稳定。对于一个近似平衡的二叉树，当改变某个子节点权重的时候，较少内容被改变</p></li></ul><p>以上具体代码可参考 <a href="https://github.com/d3/d3-hierarchy/blob/master/src/treemap/binary.js">binary 算法</a></p><h2 id="3.-treemapsquarify-treemapresquarify" tabindex="-1"><a class="header-anchor" href="#3.-treemapsquarify-treemapresquarify">¶</a> 3. T<strong>reemapSquarify &amp; <strong>T</strong>reemapResquarify</strong></h2><p>TreemapSquarify 是一种优先保证纵横比的算法，它使得分割出的矩形尽可能的接近正方形，同时利用贪婪算法优化了效率。</p><p>TreemapSquarify 是一个递归过程，每次从矩形最短边开始填充，当节点被一个个添加时，要么添加到当前行，要么在剩余的矩形行中开启一个新行，这个取决于何种操作使其纵横比最小。</p><p>一个经典例子：4*6 矩形，数据为 [6, 6, 4, 3, 2, 2, 1] , 它的分割过程和在 G2Plot 中的渲染效果如下</p>',9),B=Object(a["createElementVNode"])("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c505f1bf96d437d88162a85874b5ddf~tplv-k3u1fbpfcp-zoom-1.image",alt:"屏幕快照 2021-02-02 15.36.17.png"},null,-1),C=Object(a["createElementVNode"])("img",{src:m.a,alt:"G2Plot_simple_demo"},null,-1),G=Object(a["createStaticVNode"])('<p>如图所示，每次从最短边开始依次填充，在填充到[6, 6, 4] 时，有两个选择，Step3 填充在了当前行，Step 4 开启了新行，比较最差纵横比 Step4 更优，因此舍弃 Step3，认为当前行只应包括[6, 6] ，对其进行布局。下次递归，从新的一行，即 [4] 和剩余矩形 开始。</p><p>接下来，我们需要确定如何计算某个节点的纵横比。</p><p>我们设定: 新增节点权重为 <code>r</code> ，当前节点列表的和为 <code>s</code> ，可分配矩形的最短边为 <code>w</code> , 最长边为 <code>h</code> , 总和为 <code>S</code> 。我们要求解的值，便是当前节点在同一行时，新增节点的纵横比。（以图示 Step 3 为例， 即 r = 4, s = 16, w = 4, h = 6, S = 24)</p><ol><li>可分配矩形的总面积为 w<em>h ，节点列可分配面积为 w</em>h<em>s/S ，当前节点可分配面积为 w</em>h<em>r/S，当前节点宽为 h</em>s/S （在上述 case 中，即可分配矩形面积为 24. [6, 6, 4] 所占面积为 16, 节点 4 所分配面积为 4, 宽为 4）</li><li>根据前提条件：填充最短边。可得当前节点的长为 w*r/s (上述 case，节点 4 的长为 1)</li><li>纵横比 = Max(长/宽，宽/长)。即 Max( (w<em>S</em>r)/(s<em>s</em>h) , (s<em>s</em>h/w<em>S</em>r) ) 。 (以上述 case，即 Max（0.25, 4）)</li></ol><p>由于 <code>s/(w*h)</code> 在每次递归中都是一个定值。因此提取该系数，比较纵横比时，可仅比较。 Max( <code>(w*w*r)/(s*s)</code> , <code>(s*s)/(w*w*r)</code> )。</p><div class="warning"><p>为提高效率，在运行 TreemapSquarify 前先行排序，因此一行节点中，仅需计算权重最大节点和权重最小节点的纵横比即可，设最大权重值为 <code>max</code> ，最小为 <code>min</code> , 即计算 Max( <code>(w*w*max)/(s*s)</code> , <code>(s*s)/(w*w*min)</code> )</p></div><p>在 d3.treemapSquarify 算法中，还可以设置期待纵横比的值。在上述例子中，我们期待纵横比尽可能接近 1，即尽可能为正方形。d3.treemapSquarify 默认纵横比为黄金分割比例，即尽可能接近 0.618。具体代码可参考 <a href="https://github.com/d3/d3-hierarchy/blob/master/src/treemap/squarify.js">squarify 算法</a></p><p>现在我们来评价 TreemapSquarify 算法：</p><ul><li><p>纵横比: 效果最佳</p></li><li><p>有序性：无序，算法最开始即进行了排序</p></li><li><p>稳定性: 一般，更改某个节点权重时，可能产生较大变更</p></li></ul><p>TreemapResquarify 是在 TreemapSquarify 基础上进行了改造，即每次记录上一次使用 TreemapSquarify 生成的布局，若后续有数据更新，继续在上次生成布局的基础上直接 slice 或 dice，这样不更改节点相对位置，仅更改大小，提高了稳定性，但后续更新的布局不够理想，仅第一次布局应用了 TreemapSquarify。具体代码可参考 <a href="https://github.com/d3/d3-hierarchy/blob/master/src/treemap/resquarify.js">resquarify 算法</a></p><h2 id="zong-jie" tabindex="-1"><a class="header-anchor" href="#zong-jie">¶</a> 总结</h2><p>具体解析了各个算法的区别后，我们根据评判标准重新比较下各个算法，可以得</p><p>纵横比: Slice&amp;Dice &gt; Binary &gt; Squarify, 认为 Squarify 算法效果最好 有序性: Slice&amp;Dice &gt; Binary &gt; Squarify 稳定性: Slice&amp;Dice = Binary &gt; Squarify</p><h2 id="can-kao-wen-xian" tabindex="-1"><a class="header-anchor" href="#can-kao-wen-xian">¶</a> 参考文献</h2><ul><li><p><a href="https://github.com/xswei/d3-hierarchy/blob/master/README.md%23treemap-tiling">d3-hierarchy</a></p></li><li><p><a href="http://www.cs.umd.edu/hcil/treemap-history/">treemap-history</a></p></li><li><p><a href="https://www.win.tue.nl/%7Evanwijk/stm.pdf">Squarified Treemaps</a></p></li></ul>',15);function M(e,t){const c=Object(a["resolveComponent"])("image-viewer");return Object(a["openBlock"])(),Object(a["createElementBlock"])("section",n,[b,d,u,Object(a["createElementVNode"])("p",null,[Object(a["createVNode"])(c,{url:"../../img/webpack_bundleAnalyzer_plugin.gif"},{default:Object(a["withCtx"])(()=>[s]),_:1})]),f,h,Object(a["createElementVNode"])("p",null,[Object(a["createVNode"])(c,{url:"../../img/G2Plot_complex_demo.png"},{default:Object(a["withCtx"])(()=>[j]),_:1})]),g,Object(a["createElementVNode"])("p",null,[Object(a["createVNode"])(c,{url:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33500ddbfc2d4e21b35123006f3474f9~tplv-k3u1fbpfcp-zoom-1.image"},{default:Object(a["withCtx"])(()=>[y]),_:1})]),O,N,V,Object(a["createElementVNode"])("p",null,[Object(a["createVNode"])(c,{url:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/324b2bad6839424f9f6c4212a952e3a3~tplv-k3u1fbpfcp-zoom-1.image"},{default:Object(a["withCtx"])(()=>[w]),_:1})]),k,Object(a["createElementVNode"])("p",null,[Object(a["createVNode"])(c,{url:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aa0ac9973084d1284e7f0c4b71cdeef~tplv-k3u1fbpfcp-zoom-1.image"},{default:Object(a["withCtx"])(()=>[x]),_:1})]),E,Object(a["createElementVNode"])("p",null,[Object(a["createVNode"])(c,{url:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c898dc5474f4124a7c3fb61502aaac6~tplv-k3u1fbpfcp-zoom-1.image"},{default:Object(a["withCtx"])(()=>[S]),_:1})]),T,Object(a["createElementVNode"])("p",null,[Object(a["createVNode"])(c,{url:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4cf92bf56504c9fab8cb33bf266c248~tplv-k3u1fbpfcp-zoom-1.image"},{default:Object(a["withCtx"])(()=>[_]),_:1}),q,Object(a["createVNode"])(c,{url:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5009730674214f3a945ef75de42020c1~tplv-k3u1fbpfcp-zoom-1.image"},{default:Object(a["withCtx"])(()=>[v]),_:1}),z,Object(a["createVNode"])(c,{url:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/465aeb14eb6f4295825d06facf4d277e~tplv-k3u1fbpfcp-zoom-1.image"},{default:Object(a["withCtx"])(()=>[P]),_:1})]),D,Object(a["createElementVNode"])("p",null,[Object(a["createVNode"])(c,{url:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c505f1bf96d437d88162a85874b5ddf~tplv-k3u1fbpfcp-zoom-1.image"},{default:Object(a["withCtx"])(()=>[B]),_:1}),Object(a["createVNode"])(c,{url:"../../img/G2Plot_simple_demo.png"},{default:Object(a["withCtx"])(()=>[C]),_:1})]),G])}var A=c("b9a6"),I=c.n(A);const R={},F=I()(R,[["render",M]]);t["default"]=F},"569a":function(e,t,c){e.exports=c.p+"static/img/webpack_bundleAnalyzer_plugin.76eb1584.gif"},a1e4:function(e,t,c){e.exports=c.p+"static/img/G2Plot_complex_demo.bdd56020.png"},b9a6:function(e,t,c){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=(e,t)=>{const c=e.__vccOpts||e;for(const[a,p]of t)c[a]=p;return c}},e192:function(e,t,c){e.exports=c.p+"static/img/G2Plot_simple_demo.4d17b1c7.png"}}]);