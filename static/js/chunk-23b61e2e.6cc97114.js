(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-23b61e2e"],{"6e74":function(e,n,t){"use strict";t.r(n);var a=t("f2bf");const r={class:"blog-doc-component"},c=Object(a["createElementVNode"])("h1",null,"让你像数组一样操作Tree树结构",-1),d=Object(a["createElementVNode"])("p",null,"可以这么说，小到一个生命体，大到整个宇宙，世间万物皆是树。 现实生活中最常见的树的例子是家谱，或是公司的组织架构图。",-1),l=Object(a["createElementVNode"])("img",{src:"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc2sucWNsb3VkaW1nLmNvbS9odHRwLXNhdmUveWVoZS0xNDM2ODI2L3c5aGJ6aTJ4cWoucG5n?x-oss-process=image/format,png#pic_center",alt:"在这里插入图片描述"},null,-1),o=Object(a["createElementVNode"])("p",null,"树是一种非顺序数据结构，一种分层数据的抽象模型，它对于存储需要快速查找的数据非常有用。 一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个 节点）以及零个或多个子节点。 JS里面没有像Array一样直接的一个Tree对象，也没有处理Tree的函数，比如：遍历、查找、插入、删除等等，因此我们得自己造轮子",-1),i=Object(a["createElementVNode"])("h2",{id:"1-each",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#1-each"},"¶"),Object(a["createTextVNode"])(" 1、each")],-1),s=Object(a["createElementVNode"])("p",null,"就像Array数组一样，遍历是其他很多的操作的前提，Tree也是一样 while循环栈方式遍历，类似Array.forEach",-1),h=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"/**\n * 遍历树结构方法(while循环栈)\n * @param {Object|Array}  data  传入的数据\n * @param {function} handler 回调函数，处理每个节点，参数为当前节点对象，返回false会终止遍历\n * @param {String} mode 广度优先搜索/深度优先搜索(wide,deep)，默认：广度优先\n */\nfunction each(data, handler, mode) {\n    var stack = [].concat(data);\n    var node, children, handleRes;\n\n    while (stack.length) {\n        node = stack.shift();\n        children = node.children\n        handleRes = handler && handler(node);\n\n        if (handleRes === false) break;\n        if (Array.isArray(children)) {\n            mode == 'deep' ?\n                [].unshift.apply(stack, children) :\n                [].push.apply(stack, children);\n        }\n    }\n}\n")],-1),u=Object(a["createElementVNode"])("p",null,"递归+栈配合方式遍历：",-1),b=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"/**\n * 遍历树结构方法(递归+栈配合)\n * @param {Object|Array}  data  传入的数据\n * @param {function} handler 回调函数，处理每个节点，参数为当前节点对象，返回false会终止遍历\n * @param {String} mode 广度优先/深度优先(wide,deep)，默认：广度优先\n */\nfunction eachRecursive(data, handler, mode) {\n    var stack = [], index = -1, next, isBreak;\n    var isDeepMode = mode === 'deep';\n    var recursive = function (data) {\n        var node, nodes = [].concat(data), children;\n\n        for (var i = 0; i < nodes.length; i++) {\n            node = nodes[i]\n            children = node.children || []\n            isBreak = handler.call(node, node)\n\n            if (isBreak === false) break\n            if (children.length) {\n                [].push.apply(stack, children)\n                isDeepMode && recursive(children)\n            }\n\n            index++\n        }\n\n        next = stack[index]\n        if (isBreak !== false && !isDeepMode && next) recursive(next)\n    }\n\n    recursive(data)\n}\n")],-1),p=Object(a["createElementVNode"])("p",null,"​特点：",-1),m=Object(a["createElementVNode"])("p",null,"支持一个或多个顶点 支持中断 支持广度/深度优先",-1),j=Object(a["createElementVNode"])("h2",{id:"2-map",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#2-map"},"¶"),Object(a["createTextVNode"])(" 2、map")],-1),O=Object(a["createElementVNode"])("p",null,[Object(a["createTextVNode"])("遍历树并返回新的tree方法，利用递归进行遍历，类似Array.map"),Object(a["createElementVNode"])("br"),Object(a["createTextVNode"])(" 在map的节点处理函数中可拿到parent父亲节点的数据，以方便实现节点数据的累加与计算")],-1),f=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"/**\n * 遍历树并返回新的tree方法，利用递归进行遍历\n * @param {Object|Array}  data  传入的数据\n * @param {function} handler 处理函数，入参为当前节点\n * @return {Object|Array} 新的tree数据\n */\nfunction map(data, handler) {\n    var stack = [].concat(data);\n    var deepMap = (data, handler, parent) => {\n        return data.map(v => {\n            let node = handler.call(data, v, parent)\n\n            if (Array.isArray(v.children)) {\n                node.children = deepMap(v.children, handler, v)\n            }\n\n            return node\n        })\n    }\n\n    return deepMap(stack, handler, null)\n}\n")],-1),N=Object(a["createElementVNode"])("h2",{id:"3-find",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#3-find"},"¶"),Object(a["createTextVNode"])(" 3、find")],-1),V=Object(a["createElementVNode"])("p",null,"查找树并返回结果方法，类似Array.find",-1),v=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"/**\n * 查找树并返回结果方法，类似Array.find\n * @param {Object|Array}  data  传入的数据\n * @param {function} handler 处理函数，入参为当前节点\n * @return {Object} node节点或null\n */\nfunction find(data, handler) {\n    var result = null\n\n    each(data, node => {\n        if (handler.call(data, node)) {\n            result = node\n            return false\n        }\n    })\n\n    return result\n}\n")],-1),E=Object(a["createElementVNode"])("h2",{id:"4-filter",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#4-filter"},"¶"),Object(a["createTextVNode"])(" 4、filter")],-1),y=Object(a["createElementVNode"])("p",null,[Object(a["createTextVNode"])("过滤树节点方法，类似Array.filter"),Object(a["createElementVNode"])("br"),Object(a["createTextVNode"])(" 默认如果匹配到孩子节点会自动带上父亲节点，从而形成完整的树")],-1),x=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"/**\n * 过滤树节点方法，类似Array.filter\n * @param {Object|Array}  data  传入的数据\n * @param {function} handler 处理函数，入参为当前节点\n * @param {Boolean} withFather 是否包含父亲节点\n * @return {Object} node节点\n */\nfunction filter(data, handler, withFather = true) {\n    var stack = [].concat(data || [])\n\n    if(!withFather) {\n        var result = []\n\n        each(stack, node => {\n            var handleRes = handler.call(node, node)\n            if (handleRes === false) return false\n            if (handleRes) result.push(node)\n        })\n\n        return result\n    }\n\n    function deepFilter(node){\n        var handleRes = handler.call(node, node)\n        var childrenMatched = node.children && node.children.some(deepFilter)\n        return handleRes || childrenMatched\n    }\n\n    return stack.filter(deepFilter)\n}\n")],-1),g=Object(a["createElementVNode"])("h2",{id:"5-some",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#5-some"},"¶"),Object(a["createTextVNode"])(" 5、some")],-1),k=Object(a["createElementVNode"])("p",null,"匹配某一个节点并返回匹配结果的方法，类似Array.some",-1),A=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"/**\n * 匹配某一个节点并返回匹配结果的方法，类似Array.some\n * @param {Object|Array}  data  传入的数据\n * @param {function} handler 处理函数，入参为当前节点\n * @return {Object} Boolean\n */\nfunction some(data, handler) {\n    var result = false\n\n    each(data, node => {\n        if (handler.call(data, node)) {\n            result = true\n            return false\n        }\n    })\n\n    return result\n}\n")],-1),w=Object(a["createElementVNode"])("h2",{id:"6-every",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#6-every"},"¶"),Object(a["createTextVNode"])(" 6、every")],-1),T=Object(a["createElementVNode"])("p",null,"匹配每一个节点并返回匹配结果的方法，类似Array.every",-1),_=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"/**\n * 匹配每一个节点并返回匹配结果的方法，类似Array.every\n * @param {Object|Array}  data  传入的数据\n * @param {function} handler 处理函数，入参为当前节点\n * @return {Object} Boolean\n */\nfunction every(data, handler) {\n    var result = true\n\n    each(data, node => {\n        if (!handler.call(data, node)) {\n            result = false\n            return false\n        }\n    })\n\n    return result\n}\n")],-1),M=Object(a["createElementVNode"])("h2",{id:"7-flat",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#7-flat"},"¶"),Object(a["createTextVNode"])(" 7、flat")],-1),C=Object(a["createElementVNode"])("p",null,"树的扁平化方法(树 --\x3e 数组)，不改变原数据，返回新的数组",-1),I=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"/**\n * 树的扁平化方法(树 --\x3e 数组)，不改变原数据，返回新的数组\n * @param {Object} data 传入的数据\n * @param {String} mode 广度优先搜索/深度优先搜索，默认：广度优先(wide,deep)\n * @param {function} callback 回调函数，处理每个节点，参数为当前节点对象\n * @return {Array} result 新的数组\n */\nfunction flat(data, callback, mode) {\n    var result = [];\n    var handleNode = function (node, children) {\n        callback && callback.apply(node, [node, children]);\n        result.push(node);\n    }\n\n    each(data, handleNode, mode);\n    return result;\n}\n")],-1),R=Object(a["createElementVNode"])("h2",{id:"8-reduce",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#8-reduce"},"¶"),Object(a["createTextVNode"])(" 8、reduce")],-1),D=Object(a["createElementVNode"])("p",null,"树累加器，改变原数据",-1),B=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"/**\n * 树累加器，改变原数据\n * @param {Array|Object} data 数组或对象\n * @param {Object} fields 键值对的对象，键：在data新建的键名，值：data里的字段值\n */\nfunction reduce(data, fieldsObj, callback) {\n    if (!fieldsObj) return data;\n\n    var handleNode = function (node, children) {\n        // 累加当前节点\n        for (var key in fieldsObj) {\n            node[key] = node[key] || [];\n            node[key].push(node[fieldsObj[key]]);\n        }\n\n        // 回调处理\n        // callback && callback(node, children\n        callback && callback.apply(this, arguments);\n\n        // 累加children\n        children && children.length && children.forEach(function (item) {\n            for (var key in fieldsObj) {\n                item[key] = [].concat(node[key]);\n            }\n        });\n    };\n\n    each(data, handleNode);\n}\n")],-1),F=Object(a["createElementVNode"])("h2",{id:"9-completer",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#9-completer"},"¶"),Object(a["createTextVNode"])(" 9、completer")],-1),S=Object(a["createElementVNode"])("p",null,"补全父级链方法，传入任意节点，通过已有的数据查找并发回包括所有父级的集合",-1),L=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"/**\n * 补全父级链方法，传入任意节点，通过已有的数据查找并发回包括所有父级的集合\n * @param {Array} nodes 节点id数组\n * @param {Array} data 原始数据（未转换tree）\n * @return {Array} result 包括所有父级的集合\n */\nfunction completer(nodeIds, data) {\n    if (!data) return [];\n    if (!Array.isArray(nodeIds) || !nodeIds.length) return [];\n\n    var result = [];\n    var resultMap = {};\n    var dataMap = data.reduce((total, curr) => {\n        total[curr.id] = curr\n        return total\n    }, {})\n    var getNode = function (id) {\n        var node = dataMap[id];\n\n        if (!node || resultMap[id]) return\n\n        resultMap[id] = 1;\n        result.push(node);\n        getNode(node.parentId);\n    };\n\n    // 生成结果\n    nodeIds.forEach(function (id) {\n        getNode(id);\n    });\n\n    return result;\n}\n")],-1),W=Object(a["createElementVNode"])("h2",{id:"10-append",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#10-append"},"¶"),Object(a["createTextVNode"])(" 10、append")],-1),J=Object(a["createElementVNode"])("p",null,"插入节点方法，传入任意节点ID，在其下插入子节点",-1),H=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"/**\n * 插入节点方法，传入任意节点ID，在其下插入子节点\n * @param {String} nodeId 节点id\n * @param {Array} children 插入的字节点\n */\nfunction append(nodeId, children) {\n    if (nodeId == undefined) return;\n    if (!Array.isArray(children) || !children.length) return;\n\n    var node = find(n => n.id === nodeId)\n\n    if (!node) return;\n    if (!node.children) node.children = [];\n\n    [].push.apply(node.children, children)\n}\n")],-1),G=Object(a["createElementVNode"])("h2",{id:"11-treefrom",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#11-treefrom"},"¶"),Object(a["createTextVNode"])(" 11、TreeFrom")],-1),U=Object(a["createElementVNode"])("p",null,"数组 --\x3e 树，利用堆栈转换，不改变数组本身，返回新的对象，支持乱序，类似Array.from",-1),X=Object(a["createElementVNode"])("h3",{id:"yi-ci-bian-li-shi-xian",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#yi-ci-bian-li-shi-xian"},"¶"),Object(a["createTextVNode"])(" 一次遍历实现：")],-1),Z=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"/**\n * 数组 --\x3e 树，利用堆栈转换，不改变数组本身，返回新的数组或对象，支持乱序\n * @param  {Array}  data  数组\n * @return {Array|Object} 数组或对象\n * 原数据要求：top顶点的parentId必须为0或者null/undefined\n */\nfunction TreeFrom(data) {\n    if (!data || !data.length) return {};\n\n    var copy = data.map(function (v) {\n        return Object.assign({}, v)\n    });\n    var id, pid, node, parent;\n    var hash = {};\n    var tops = [];\n\n    copy.forEach(function (item) {\n        id = item.id;\n        pid = item.parentId;\n        node = hash[id]\n\n        // 如果已存提前存在，证明是父亲节点，先连接他的孩子，支持乱序的重点\n        if (node) item.children = node.children;\n\n        hash[id] = item;\n\n        if (pid) {\n            parent = hash[pid] = hash[pid] || {};\n            parent.children = (parent.children || []).concat(item);\n        } else {\n            tops.push(item);\n        }\n    });\n\n    return tops;\n}\n")],-1),P=Object(a["createElementVNode"])("h3",{id:"er-ci-bian-li-shi-xian",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#er-ci-bian-li-shi-xian"},"¶"),Object(a["createTextVNode"])(" 二次遍历实现：")],-1),q=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"/**\n * 数组 --\x3e 树，利用堆栈转换，不改变数组本身，返回新的对象，支持乱序\n * @param  {Array}  data  数组\n * @return {Object} 数组或对象\n * 原数据要求：top顶点的parentId必须为0或者null/undefined\n */\nfunction TreeFrom2(data) {\n    if (!data || !data.length) return {};\n\n    var hash = {};\n    var tops = [];\n    var node, parent\n    var copy = data.map(function (v) {\n        return Object.assign({}, v)\n    });\n\n    // 罗列所有节点\n    copy.forEach(function (item) {\n        hash[item.id] = item;\n    });\n    // console.log('hash --\x3e ', hash)\n\n    // 连接所有节点\n    for (var item in hash) {\n        node = hash[item];\n        parent = hash[node.parentId];\n\n        if (!parent) tops.push(node);\n        else parent.children = (parent.children || []).concat(node);\n    };\n\n    return tops;\n}\n")],-1),z=Object(a["createElementVNode"])("h2",{id:"12-getdepth",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#12-getdepth"},"¶"),Object(a["createTextVNode"])(" 12、getDepth")],-1),K=Object(a["createElementVNode"])("p",null,"获得数的最大深度方法",-1),Q=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"/**\n * 获得数的最大深度方法\n * @param {Object|Array}  data  传入的数据\n */\nfunction getDepth(data) {\n  let reuslt = []\n  let nodes = [].concat(data)\n\n  const iteration = (node, level) => {\n    if (!node) return\n\n    if (!reuslt[level]) {\n      reuslt[level] = []\n    }\n\n    reuslt[level].push(node.val)\n\n    if (Array.isArray(node.children)) {\n      node.children.forEach(childNode => iteration(childNode, level + 1));\n    }\n\n  }\n\n  nodes.forEach(node => iteration(node, 0))\n  return reuslt.length\n}\n")],-1);function Y(e,n){const t=Object(a["resolveComponent"])("image-viewer"),Y=Object(a["resolveComponent"])("code-viewer");return Object(a["openBlock"])(),Object(a["createElementBlock"])("section",r,[c,d,Object(a["createElementVNode"])("p",null,[Object(a["createVNode"])(t,{url:"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc2sucWNsb3VkaW1nLmNvbS9odHRwLXNhdmUveWVoZS0xNDM2ODI2L3c5aGJ6aTJ4cWoucG5n?x-oss-process=image/format,png#pic_center"},{default:Object(a["withCtx"])(()=>[l]),_:1})]),o,i,s,Object(a["createVNode"])(Y,null,{default:Object(a["withCtx"])(()=>[h]),_:1}),u,Object(a["createVNode"])(Y,null,{default:Object(a["withCtx"])(()=>[b]),_:1}),p,m,j,O,Object(a["createVNode"])(Y,null,{default:Object(a["withCtx"])(()=>[f]),_:1}),N,V,Object(a["createVNode"])(Y,null,{default:Object(a["withCtx"])(()=>[v]),_:1}),E,y,Object(a["createVNode"])(Y,null,{default:Object(a["withCtx"])(()=>[x]),_:1}),g,k,Object(a["createVNode"])(Y,null,{default:Object(a["withCtx"])(()=>[A]),_:1}),w,T,Object(a["createVNode"])(Y,null,{default:Object(a["withCtx"])(()=>[_]),_:1}),M,C,Object(a["createVNode"])(Y,null,{default:Object(a["withCtx"])(()=>[I]),_:1}),R,D,Object(a["createVNode"])(Y,null,{default:Object(a["withCtx"])(()=>[B]),_:1}),F,S,Object(a["createVNode"])(Y,null,{default:Object(a["withCtx"])(()=>[L]),_:1}),W,J,Object(a["createVNode"])(Y,null,{default:Object(a["withCtx"])(()=>[H]),_:1}),G,U,X,Object(a["createVNode"])(Y,null,{default:Object(a["withCtx"])(()=>[Z]),_:1}),P,Object(a["createVNode"])(Y,null,{default:Object(a["withCtx"])(()=>[q]),_:1}),z,K,Object(a["createVNode"])(Y,null,{default:Object(a["withCtx"])(()=>[Q]),_:1})])}var $=t("b9a6"),ee=t.n($);const ne={},te=ee()(ne,[["render",Y]]);n["default"]=te},b9a6:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=(e,n)=>{const t=e.__vccOpts||e;for(const[a,r]of n)t[a]=r;return t}}}]);