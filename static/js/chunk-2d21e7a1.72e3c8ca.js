(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d21e7a1"],{d670:function(n,e,a){"use strict";a.r(e);var r=a("f2bf");const t={class:"blog-doc-component"},c=Object(r["p"])('<p></p><h2 id="rang-ni-xiang-shu-zu-yi-yang-cao-zuo-treeshu-jie-gou" tabindex="-1"><a class="header-anchor" href="#rang-ni-xiang-shu-zu-yi-yang-cao-zuo-treeshu-jie-gou">¶</a> 让你像数组一样操作Tree树结构</h2><p>可以这么说，小到一个生命体，大到整个宇宙，世间万物皆是树。 现实生活中最常见的树的例子是家谱，或是公司的组织架构图。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc2sucWNsb3VkaW1nLmNvbS9odHRwLXNhdmUveWVoZS0xNDM2ODI2L3c5aGJ6aTJ4cWoucG5n?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"></p><p>树是一种非顺序数据结构，一种分层数据的抽象模型，它对于存储需要快速查找的数据非常有用。 一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个 节点）以及零个或多个子节点。 JS里面没有像Array一样直接的一个Tree对象，也没有处理Tree的函数，比如：遍历、查找、插入、删除等等，因此我们得自己造轮子</p><h3 id="1-each" tabindex="-1"><a class="header-anchor" href="#1-each">¶</a> 1、each</h3><p>就像Array数组一样，遍历是其他很多的操作的前提，Tree也是一样 while循环栈方式遍历，类似Array.forEach</p>',7),d=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"/**\n * 遍历树结构方法(while循环栈)\n * @param {Object|Array}  data  传入的数据\n * @param {function} handler 回调函数，处理每个节点，参数为当前节点对象，返回false会终止遍历\n * @param {String} mode 广度优先搜索/深度优先搜索(wide,deep)，默认：广度优先\n */\neach: function (data, handler, mode) {\n    var stack = [].concat(data);\n    var node, children, handleRes;\n\n    while (stack.length) {\n        node = stack.shift();\n        children = node.children\n        handleRes = handler && handler(node);\n\n        if (handleRes === false) break;\n        if (Array.isArray(children)) {\n            mode == 'deep' ?\n                [].unshift.apply(stack, children) :\n                [].push.apply(stack, children);\n        }\n    }\n}\n")],-1),l=Object(r["o"])("p",null,"递归+栈配合方式遍历：",-1),o=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"/**\n * 遍历树结构方法(递归+栈配合)\n * @param {Object|Array}  data  传入的数据\n * @param {function} handler 回调函数，处理每个节点，参数为当前节点对象，返回false会终止遍历\n * @param {String} mode 广度优先/深度优先(wide,deep)，默认：广度优先\n */\neachRecursive: function (data, handler, mode) {\n    var stack = [], index = -1, next, isBreak;\n    var isDeepMode = mode === 'deep';\n    var recursive = function (data) {\n        var node, nodes = [].concat(data), children;\n\n        for (var i = 0; i < nodes.length; i++) {\n            node = nodes[i]\n            children = node.children || []\n            isBreak = handler.call(node, node)\n\n            if (isBreak === false) break\n            if (children.length) {\n                [].push.apply(stack, children)\n                isDeepMode && recursive(children)\n            }\n\n            index++\n        }\n\n        next = stack[index]\n        if (isBreak !== false && !isDeepMode && next) recursive(next)\n    }\n\n    recursive(data)\n}\n")],-1),i=Object(r["o"])("p",null,"​特点：",-1),s=Object(r["o"])("p",null,"支持一个或多个顶点 支持中断 支持广度/深度优先",-1),h=Object(r["o"])("h3",{id:"2-map",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#2-map"},"¶"),Object(r["q"])(" 2、map")],-1),u=Object(r["o"])("p",null,"遍历树并返回新的tree方法，利用递归进行遍历，类似Array.map",-1),b=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"/**\n * 遍历树并返回新的tree方法，利用递归进行遍历\n * @param {Object|Array}  data  传入的数据\n * @param {function} handler 处理函数，入参为当前节点\n * @return {Object|Array} 新的tree数据\n */\nmap: function (data, handler) {\n    var stack = [].concat(data);\n    var getNodes = (data, handler) => {\n        return data.map(v => {\n            let node = handler.call(data, v)\n\n            if (Array.isArray(v.children) && v.children.length) {\n                node.children = getNodes(v.children, handler)\n            }\n\n            return node\n        })\n    }\n\n    return getNodes(stack, handler)\n}\n")],-1),p=Object(r["o"])("h3",{id:"3-find",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#3-find"},"¶"),Object(r["q"])(" 3、find")],-1),j=Object(r["o"])("p",null,"查找树并返回结果方法，类似Array.find",-1),f=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"/**\n * 查找树并返回结果方法，类似Array.find\n * @param {Object|Array}  data  传入的数据\n * @param {function} handler 处理函数，入参为当前节点\n * @return {Object} node节点或null\n */\nfind: function (data, handler) {\n    var result = null\n\n    this.each(data, node => {\n        if (handler.call(data, node)) {\n            result = node\n            return false\n        }\n    })\n\n    return result\n}\n")],-1),O=Object(r["o"])("h3",{id:"4-filter",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#4-filter"},"¶"),Object(r["q"])(" 4、filter")],-1),m=Object(r["o"])("p",null,"过滤树节点方法，类似Array.filter",-1),v=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"/**\n * 过滤树节点方法，类似Array.filter\n * @param {Object|Array}  data  传入的数据\n * @param {function} handler 处理函数，入参为当前节点\n * @return {Object} node节点\n */\nfilter: function (data, handler) {\n    var result = [], handleRes\n\n    this.each(data, node => {\n        handleRes = handler.call(data, node)\n        if (handleRes === false) return false\n        if (handleRes) result.push(node)\n    })\n\n    return result\n}\n")],-1),y=Object(r["o"])("h3",{id:"5-some",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#5-some"},"¶"),Object(r["q"])(" 5、some")],-1),g=Object(r["o"])("p",null,"匹配某一个节点并返回匹配结果的方法，类似Array.some",-1),A=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"/**\n * 匹配某一个节点并返回匹配结果的方法，类似Array.some\n * @param {Object|Array}  data  传入的数据\n * @param {function} handler 处理函数，入参为当前节点\n * @return {Object} Boolean\n */\nsome: function (data, handler) {\n    var result = false\n\n    this.each(data, node => {\n        if (handler.call(data, node)) {\n            result = true\n            return false\n        }\n    })\n\n    return result\n}\n")],-1),k=Object(r["o"])("h3",{id:"6-every",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#6-every"},"¶"),Object(r["q"])(" 6、every")],-1),x=Object(r["o"])("p",null,"匹配每一个节点并返回匹配结果的方法，类似Array.every",-1),I=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"/**\n * 匹配每一个节点并返回匹配结果的方法，类似Array.every\n * @param {Object|Array}  data  传入的数据\n * @param {function} handler 处理函数，入参为当前节点\n * @return {Object} Boolean\n */\nevery: function (data, handler) {\n    var result = true\n\n    this.each(data, node => {\n        if (!handler.call(data, node)) {\n            result = false\n            return false\n        }\n    })\n\n    return result\n}\n")],-1),w=Object(r["o"])("h3",{id:"7-flat",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#7-flat"},"¶"),Object(r["q"])(" 7、flat")],-1),N=Object(r["o"])("p",null,"树的扁平化方法(树 --\x3e 数组)，不改变原数据，返回新的数组",-1),_=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"/**\n * 树的扁平化方法(树 --\x3e 数组)，不改变原数据，返回新的数组\n * @param {Object} data 传入的数据\n * @param {String} mode 广度优先搜索/深度优先搜索，默认：广度优先(wide,deep)\n * @param {function} callback 回调函数，处理每个节点，参数为当前节点对象\n * @return {Array} result 新的数组\n */\nflat: function (data, callback, mode) {\n    var result = [];\n    var handleNode = function (node, children) {\n        callback && callback.apply(node, [node, children]);\n        result.push(node);\n    }\n\n    this.each(data, handleNode, mode);\n    return result;\n}\n")],-1),q=Object(r["o"])("h3",{id:"8-reduce",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#8-reduce"},"¶"),Object(r["q"])(" 8、reduce")],-1),M=Object(r["o"])("p",null,"树累加器，改变原数据",-1),R=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"/**\n * 树累加器，改变原数据\n * @param {Array|Object} data 数组或对象\n * @param {Object} fields 键值对的对象，键：在data新建的键名，值：data里的字段值\n */\nreduce: function (data, fieldsObj, callback) {\n    if (!fieldsObj) return data;\n\n    var handleNode = function (node, children) {\n        // 累加当前节点\n        for (var key in fieldsObj) {\n            node[key] = node[key] || [];\n            node[key].push(node[fieldsObj[key]]);\n        }\n\n        // 回调处理\n        // callback && callback(node, children\n        callback && callback.apply(this, arguments);\n\n        // 累加children\n        children && children.length && children.forEach(function (item) {\n            for (var key in fieldsObj) {\n                item[key] = [].concat(node[key]);\n            }\n        });\n    };\n\n    this.each(data, handleNode);\n}\n")],-1),T=Object(r["o"])("h3",{id:"9-completer",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#9-completer"},"¶"),Object(r["q"])(" 9、completer")],-1),D=Object(r["o"])("p",null,"补全父级链方法，传入任意节点，通过已有的数据查找并发回包括所有父级的集合",-1),S=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"/**\n * 补全父级链方法，传入任意节点，通过已有的数据查找并发回包括所有父级的集合\n * @param {Array} nodes 节点id数组\n * @param {Array} data 原始数据（未转换tree）\n * @return {Array} result 包括所有父级的集合\n */\ncompleter: function (nodeIds, data) {\n    if (!data) return [];\n    if (!Array.isArray(nodeIds) || !nodeIds.length) return [];\n\n    var result = [];\n    var resultMap = {};\n    var dataMap = data.reduce((total, curr) => {\n        total[curr.id] = curr\n        return total\n    }, {})\n    var getNode = function (id) {\n        var node = dataMap[id];\n\n        if (!node || resultMap[id]) return\n\n        resultMap[id] = 1;\n        result.push(node);\n        getNode(node.parentId);\n    };\n\n    // 生成结果\n    nodeIds.forEach(function (id) {\n        getNode(id);\n    });\n\n    return result;\n}\n")],-1),B=Object(r["o"])("h3",{id:"10-append",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#10-append"},"¶"),Object(r["q"])(" 10、append")],-1),E=Object(r["o"])("p",null,"插入节点方法，传入任意节点ID，在其下插入子节点",-1),J=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"/**\n * 插入节点方法，传入任意节点ID，在其下插入子节点\n * @param {String} nodeId 节点id\n * @param {Array} children 插入的字节点\n */\nappend: function (nodeId, children) {\n    if (nodeId == undefined) return;\n    if (!Array.isArray(children) || !children.length) return;\n\n    var node = this.find(n => n.id === nodeId)\n\n    if (!node) return;\n    if (!node.children) node.children = [];\n\n    [].push.apply(node.children, children)\n}\n")],-1),z=Object(r["o"])("h3",{id:"11-treefrom",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#11-treefrom"},"¶"),Object(r["q"])(" 11、TreeFrom")],-1),L=Object(r["o"])("p",null,"数组 --\x3e 树，利用堆栈转换，不改变数组本身，返回新的对象，支持乱序，类似Array.from",-1),W=Object(r["o"])("h4",{id:"yi-ci-bian-li-shi-xian",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#yi-ci-bian-li-shi-xian"},"¶"),Object(r["q"])(" 一次遍历实现：")],-1),F=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"/**\n * 数组 --\x3e 树，利用堆栈转换，不改变数组本身，返回新的数组或对象，支持乱序\n * @param  {Array}  data  数组\n * @return {Array|Object} 数组或对象\n * 原数据要求：top顶点的parentId必须为0或者null/undefined\n */\nTreeFrom: function (data) {\n    if (!data || !data.length) return {};\n\n    var copy = data.map(function (v) {\n        return Object.assign({}, v)\n    });\n    var id, pid, node, parent;\n    var hash = {};\n    var tops = [];\n\n    copy.forEach(function (item) {\n        id = item.id;\n        pid = item.parentId;\n        node = hash[id]\n\n        // 如果已存提前存在，证明是父亲节点，先连接他的孩子，支持乱序的重点\n        if (node) item.children = node.children;\n\n        hash[id] = item;\n\n        if (pid) {\n            parent = hash[pid] = hash[pid] || {};\n            parent.children = (parent.children || []).concat(item);\n        } else {\n            tops.push(item);\n        }\n    });\n\n    return tops;\n}\n")],-1),H=Object(r["o"])("h4",{id:"er-ci-bian-li-shi-xian",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#er-ci-bian-li-shi-xian"},"¶"),Object(r["q"])(" 二次遍历实现：")],-1),G=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"/**\n * 数组 --\x3e 树，利用堆栈转换，不改变数组本身，返回新的对象，支持乱序\n * @param  {Array}  data  数组\n * @return {Object} 数组或对象\n * 原数据要求：top顶点的parentId必须为0或者null/undefined\n */\nTreeFrom2: function (data) {\n    if (!data || !data.length) return {};\n\n    var hash = {};\n    var tops = [];\n    var node, parent\n    var copy = data.map(function (v) {\n        return Object.assign({}, v)\n    });\n\n    // 罗列所有节点\n    copy.forEach(function (item) {\n        hash[item.id] = item;\n    });\n    // console.log('hash --\x3e ', hash)\n\n    // 连接所有节点\n    for (var item in hash) {\n        node = hash[item];\n        parent = hash[node.parentId];\n\n        if (!parent) tops.push(node);\n        else parent.children = (parent.children || []).concat(node);\n    };\n\n    return tops;\n}\n")],-1);function V(n,e){const a=Object(r["T"])("code-viewer");return Object(r["K"])(),Object(r["n"])("section",t,[c,Object(r["r"])(a,null,{default:Object(r["hb"])(()=>[d]),_:1}),l,Object(r["r"])(a,null,{default:Object(r["hb"])(()=>[o]),_:1}),i,s,h,u,Object(r["r"])(a,null,{default:Object(r["hb"])(()=>[b]),_:1}),p,j,Object(r["r"])(a,null,{default:Object(r["hb"])(()=>[f]),_:1}),O,m,Object(r["r"])(a,null,{default:Object(r["hb"])(()=>[v]),_:1}),y,g,Object(r["r"])(a,null,{default:Object(r["hb"])(()=>[A]),_:1}),k,x,Object(r["r"])(a,null,{default:Object(r["hb"])(()=>[I]),_:1}),w,N,Object(r["r"])(a,null,{default:Object(r["hb"])(()=>[_]),_:1}),q,M,Object(r["r"])(a,null,{default:Object(r["hb"])(()=>[R]),_:1}),T,D,Object(r["r"])(a,null,{default:Object(r["hb"])(()=>[S]),_:1}),B,E,Object(r["r"])(a,null,{default:Object(r["hb"])(()=>[J]),_:1}),z,L,W,Object(r["r"])(a,null,{default:Object(r["hb"])(()=>[F]),_:1}),H,Object(r["r"])(a,null,{default:Object(r["hb"])(()=>[G]),_:1})])}var K=a("6b0d"),U=a.n(K);const X={},Z=U()(X,[["render",V]]);e["default"]=Z}}]);