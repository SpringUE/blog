(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0db866"],{"6fdd":function(e,n,t){"use strict";t.r(n);var c=t("f2bf");const a={class:"blog-doc-component"},s=Object(c["o"])("p",null,null,-1),o=Object(c["o"])("h2",{id:"jian-yi-bu-zou-kong-zhi-qi",tabindex:"-1"},[Object(c["o"])("a",{class:"header-anchor",href:"#jian-yi-bu-zou-kong-zhi-qi"},"¶"),Object(c["q"])(" 简易步骤控制器")],-1),r=Object(c["o"])("h3",{id:"jian-jie",tabindex:"-1"},[Object(c["o"])("a",{class:"header-anchor",href:"#jian-jie"},"¶"),Object(c["q"])(" 简介")],-1),u=Object(c["o"])("p",null,[Object(c["q"])("不少复杂函数中都存在一个问题，逻辑步骤或分支较多，很多时候我们都采用if else/Promise等来处理，而有些场景我们不得不额外把一部分逻辑封装成一个函数待以重用。"),Object(c["o"])("br"),Object(c["q"])(" 这些问题便会使得整个函数变得更复杂和难以维护，借助Promise.then思路我们可以模拟一个步骤控制器step来解决此问题")],-1),l=Object(c["o"])("p",null,"调用示例：",-1),i=Object(c["o"])("pre",null,[Object(c["o"])("code",{class:"language-javascript"},"step(next => {\n  // some condition\n  next()\n})\n.step(next => {\n  // do something\n})\n")],-1),b=Object(c["o"])("p",null,"step函数体可实现异步/同步效果，这取决于next的执行时机.",-1),p=Object(c["o"])("h3",{id:"zhun-bei",tabindex:"-1"},[Object(c["o"])("a",{class:"header-anchor",href:"#zhun-bei"},"¶"),Object(c["q"])(" 准备")],-1),j=Object(c["o"])("p",null,"首先，step是一个函数，并且可以反复的调用自身：",-1),h=Object(c["o"])("pre",null,[Object(c["o"])("code",{class:"language-javascript"},"function step(excuter) {\n  if(!excuter || typeof excuter !== 'function') {\n    return false\n  }\n\n  // do something...\n  \n  return {\n    step(excuter) {\n      return this\n    }\n  }\n}\n")],-1),d=Object(c["o"])("p",null,"在函数执行后返回一个对象，包含step方法，step方法执行后又返回这个对象本身，从而达到重复调用",-1),x=Object(c["o"])("h3",{id:"sheng-cheng-bu-zou-dui-lie",tabindex:"-1"},[Object(c["o"])("a",{class:"header-anchor",href:"#sheng-cheng-bu-zou-dui-lie"},"¶"),Object(c["q"])(" 生成步骤队列")],-1),O=Object(c["o"])("p",null,"在每一步执行时，把任务本身放入任务队列中，供下一步使用",-1),f=Object(c["o"])("pre",null,[Object(c["o"])("code",{class:"language-javascript"},"function step(excuter) {\n  if(!excuter || typeof excuter !== 'function') {\n    return false\n  }\n  \n  const steps = []\n  \n  return {\n    step(excuter) {\n      steps.push(excuter)\n      return this\n    }\n  }\n}\n")],-1),g=Object(c["o"])("h3",{id:"zhi-xing-bu-zou",tabindex:"-1"},[Object(c["o"])("a",{class:"header-anchor",href:"#zhi-xing-bu-zou"},"¶"),Object(c["q"])(" 执行步骤")],-1),y=Object(c["o"])("p",null,[Object(c["q"])("执行步骤：第一步通过微任务异步执行，后面的步骤可同步可异步，取决于上一步执行完成的时机."),Object(c["o"])("br"),Object(c["q"])(" 注意：由于生成步骤队列需要优先生成，故此第一步只能设为异步执行.")],-1),v=Object(c["o"])("pre",null,[Object(c["o"])("code",{class:"language-javascript"},"function step(excuter) {\n  if(!excuter || typeof excuter !== 'function') {\n    return false\n  }\n  \n  const steps = []\n  const next = (data) => {\n    if(!steps.length) {\n      return false\n    }\n\n    const stepExceter = steps.shift()\n    stepExceter(next, context)\n  }\n\n  window.queueMicrotask(() => {\n    excuter(next, context)\n  })\n  \n  return {\n    step(excuter) {\n      steps.push(excuter)\n      return this\n    }\n  }\n}\n")],-1),k=Object(c["o"])("h3",{id:"bu-zou-shu-ju",tabindex:"-1"},[Object(c["o"])("a",{class:"header-anchor",href:"#bu-zou-shu-ju"},"¶"),Object(c["q"])(" 步骤数据")],-1),w=Object(c["o"])("p",null,"每个步骤都是一个独立函数，不利于变量传递，因此在执行的时候常常需要储存或取数.",-1),m=Object(c["o"])("pre",null,[Object(c["o"])("code",{class:"language-javascript"},"const context = {\n  data: new Map(),\n  prevData: null,\n}\n\ncontext.setData = (key, value) => {\n  if(context.data.has(key)) {\n    throw new Error(`key: ${key}, 已存在!`)\n  }\n\n  context.data.set(key, value)\n}\n\ncontext.getData = (key) => {\n  return context.data.get(key)\n}\n")],-1),q=Object(c["o"])("h3",{id:"wan-zheng-dai-ma",tabindex:"-1"},[Object(c["o"])("a",{class:"header-anchor",href:"#wan-zheng-dai-ma"},"¶"),Object(c["q"])(" 完整代码")],-1),z=Object(c["o"])("pre",null,[Object(c["o"])("code",{class:"language-javascript"},"// util.function.js\n\nexport function step(excuter) {\n  if(!excuter || typeof excuter !== 'function') {\n    return false\n  }\n  \n  const context = {\n    data: new Map(),\n    prevData: null,\n  }\n  const steps = []\n  const next = (data) => {\n    if(!steps.length) {\n      return false\n    }\n\n    context.prevData = data\n\n    const stepExceter = steps.shift()\n    stepExceter(next, context)\n  }\n\n  context.setData = (key, value) => {\n    if(context.data.has(key)) {\n      throw new Error(`key: ${key}, 已存在!`)\n    }\n\n    context.data.set(key, value)\n  }\n\n  context.getData = (key) => {\n    return context.data.get(key)\n  }\n\n  window.queueMicrotask(() => {\n    excuter(next, context)\n  })\n  \n  return {\n    step(excuter) {\n      steps.push(excuter)\n      return this\n    }\n  }\n}\n\nexport default {\n  step\n}\n")],-1),D=Object(c["o"])("h3",{id:"diao-yong-yang-li",tabindex:"-1"},[Object(c["o"])("a",{class:"header-anchor",href:"#diao-yong-yang-li"},"¶"),Object(c["q"])(" 调用样例")],-1),E=Object(c["o"])("pre",null,[Object(c["o"])("code",{class:"language-javascript"},"runAction(item, tab) {\n  const {action,validateInput} = item\n  const constFunction = [\n    'copyResult', 'clearResult', 'clearAll'\n  ]\n  \n  try {\n    if(constFunction.includes(action)) {\n      return this[action](tab)\n    }\n\n    step(next => {\n      if(!action) {\n        throw new Error('该动作不是一个函数，请检查配置.')\n      }\n      next()\n    })\n    .step(next => {\n      // 需要校验\n      if(validateInput && tab.inputs.length > 1) {\n        this.$refs[tab.name][0].validate().then(() => {\n          next()\n        })\n      } else {\n        next()\n      }\n    })\n    .step(next => {\n      const params = tab.inputs.map(x => {\n        let value = tab.inputModel[x.name]\n        return x.transform === 'json' ? JSON.parse(value) : value\n      })\n\n      let result = action.apply(this, params)\n      if (result instanceof Promise) {\n        result.then(res => {\n          next(res)\n        })\n      } else {\n        next(result)\n      }\n    })\n    .step((next, ctx) => {\n      this.updateOutputResult(tab.output, ctx.prevData)\n    })\n\n  } catch (error) {\n    message.error(error.message);\n  }\n}\n")],-1);function _(e,n){const t=Object(c["T"])("code-viewer");return Object(c["K"])(),Object(c["n"])("section",a,[s,o,r,u,l,Object(c["r"])(t,null,{default:Object(c["hb"])(()=>[i]),_:1}),b,p,j,Object(c["r"])(t,null,{default:Object(c["hb"])(()=>[h]),_:1}),d,x,O,Object(c["r"])(t,null,{default:Object(c["hb"])(()=>[f]),_:1}),g,y,Object(c["r"])(t,null,{default:Object(c["hb"])(()=>[v]),_:1}),k,w,Object(c["r"])(t,null,{default:Object(c["hb"])(()=>[m]),_:1}),q,Object(c["r"])(t,null,{default:Object(c["hb"])(()=>[z]),_:1}),D,Object(c["r"])(t,null,{default:Object(c["hb"])(()=>[E]),_:1})])}var M=t("6b0d"),J=t.n(M);const P={},R=J()(P,[["render",_]]);n["default"]=R}}]);