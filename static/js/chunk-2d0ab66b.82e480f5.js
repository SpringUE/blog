(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0ab66b"],{"14b4":function(t,e,n){"use strict";n.r(e);var r=n("f2bf");const s={class:"blog-doc-component"},a=Object(r["p"])('<p></p><h1>Vue大型项目如何统一管理API</h1><p>当项目有多模块，且每个模块都有不少接口时，理应考虑分模块独立接口开发，类似后端的微服务化。</p><h2 id="yi-xu-qiu" tabindex="-1"><a class="header-anchor" href="#yi-xu-qiu">¶</a> 一、需求：</h2><p>1.API独立管理； 2.按模块拆分； 3.拦截控制； 4.响应数据一致化； 5.消息提示</p><h2 id="er-shi-xian" tabindex="-1"><a class="header-anchor" href="#er-shi-xian">¶</a> 二、实现：</h2><h3 id="1.mu-lu-jie-gou-she-ji" tabindex="-1"><a class="header-anchor" href="#1.mu-lu-jie-gou-she-ji">¶</a> 1.目录结构设计：</h3>',7),o=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"src/api/index.js // 入口(从main.js引入)\nsrc/api/configs.js // 全局配置\nsrc/api/request.js // 封装的主程序\nsrc/api/common.js // 公共类api接口\nsrc/api/modules // 模块-对齐微服务\n")],-1),c=Object(r["o"])("h3",{id:"2.quan-liu-cheng",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#2.quan-liu-cheng"},"¶"),Object(r["q"])(" 2.全流程：")],-1),i=Object(r["o"])("p",null,"1.引入axios --\x3e 2.全局配置 --\x3e 3.实例配置 --\x3e 4.注入Vue原型 --\x3e 5.实例调用 --\x3e 6.请求拦截 --\x3e 7.请求 --\x3e 8.响应 --\x3e 9.响应拦截 --\x3e 10.数据解析 --\x3e 11.响应提示",-1),l=Object(r["o"])("h3",{id:"3.lan-jie-kong-zhi",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#3.lan-jie-kong-zhi"},"¶"),Object(r["q"])(" 3.拦截控制：")],-1),u=Object(r["o"])("p",null,"配置类型：全局配置, 请求拦截, 响应拦截 事件钩子：",-1),p=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"beforeRequest, \nrequestError, \nresponse, \nresponseError\n")],-1),d=Object(r["o"])("h3",{id:"4.shu-ju-yi-zhi-hua",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#4.shu-ju-yi-zhi-hua"},"¶"),Object(r["q"])(" 4.数据一致化：")],-1),g=Object(r["o"])("p",null,"返回对象的封装:",-1),b=Object(r["o"])("ul",null,[Object(r["o"])("li",null,"内容"),Object(r["o"])("li",null,"分页"),Object(r["o"])("li",null,"正常响应"),Object(r["o"])("li",null,"报错响应"),Object(r["o"])("li",null,"提示信息")],-1),h=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"{\n    result: any, // 内容\n    page: {} || null, // 分页\n    response: {}, // 正常响应\n    error: {}, // 报错响应\n    baseMessage: String, // 基础成功/错误信息\n    presetMessage: String, // 预设成功/错误信息\n    message(msg) {}, // 提示信息\n    notify(msg) {}, // 右侧通知\n\n}\n")],-1),m=Object(r["o"])("h3",{id:"5.zhu-ru-vue.prototypeyuan-xing",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#5.zhu-ru-vue.prototypeyuan-xing"},"¶"),Object(r["q"])(" 5.注入vue.prototype原型")],-1),j=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"// src/index.js\nimport common from './common';\nimport article from './modules/article';\n\nconst API =  {\n\t...common,\n\tarticle\n}\n\nexport default {\n\tinstall(Vue, options) {\n\t\tVue.prototype.$api = API\n\t}\n}\n\n\n// src/main.js\nimport api from ./api\nvue.prototype.$api = api\n")],-1),f=Object(r["o"])("h3",{id:"6.jie-kou-shi-li-pei-zhi",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#6.jie-kou-shi-li-pei-zhi"},"¶"),Object(r["q"])(" 6.接口实例配置：")],-1),O=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"// src/api/common.js\nimport request from ./request\n\nconst $api = request.create({\n    baseURL: '/api/user',\n    timeout: 1000 * 10\n})\n\n/*\n接口适配层函数命名规范：\n新增：addXXX\n删除：deleteXXX\n更新：updateXXX\n根据ID查询记录：getXXXDetail\n条件查询一条记录：findOneXXX\n条件查询：findXXXs\n查询所有记录：getAllXXXs\n分页查询：getXXXPage\n搜索：searchXXX\n其余个性化接口根据语义进行命名\n*/\n\nexport default {\n    getUsersPage(req = {}) {\n        let {params, page} = req\n        return $api.get({\n            url: '/page',\n            params: {id: params && params.id, ...page}\n        })\n    },\n    addUser(req = {}) {\n        let { data } = req\n        return $api.post({\n            url: '/api/user',\n            data: data.map(x => x),\n            headers: {\n                'content-type': 'application/json'\n            },\n            // 结果验证(从200状态中返回的结果合格校验)\n            validator(res) {\n                return res.data && res.data.code === 200\n            },\n            // 结果过滤器\n            filter(res) {\n                return res.data.map(x => x)\n            },\n            // 出错消息过滤器\n            errorMessage(err) {\n                return err.response.data.message\n            },\n            // 成功消息过滤器\n            successMessage(res) {\n                return '新增用户成功！'\n            }\n        })\n    }\n}\n")],-1),x=Object(r["o"])("h3",{id:"7.zu-jian-nei-diao-yong-pei-zhi",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#7.zu-jian-nei-diao-yong-pei-zhi"},"¶"),Object(r["q"])(" 7.组件内调用配置：")],-1),M=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"// demo.vue\nthis.$api.getUsersPage({\n    params: {keyword: 'xxx'},\n    page: {pageSize: 10, currPage: 1},\n})\n.then(res => {\n    let {result, page, message} = res\n    message('用户加载成功！')\n})\n.catch(err => {\n    let {presetMessage, message, notify} = res\n    message('用户加载失败，'+ presetMessage)\n})\n")],-1),q=Object(r["o"])("h3",{id:"8.zhu-cheng-she-ji",tabindex:"-1"},[Object(r["o"])("a",{class:"header-anchor",href:"#8.zhu-cheng-she-ji"},"¶"),Object(r["q"])(" 8.主程设计")],-1),y=Object(r["o"])("pre",null,[Object(r["o"])("code",{class:"language-javascript"},"// src/api/request.js \nimport axios from 'axios';\nimport configs from './configs';\nimport router from '../router';\nimport store from '../store';\nimport { Message, Notification } from 'element-ui'\n\n/** \n * http 状态码\n */\n\nconst httpStatusMap = {\n\t// 1 消息\n\t'100': 'Continue',\n\t'101': 'Switching Protocols',\n\t'102': 'Processing',\n\t// 2 成功\n\t'200': 'OK',\n\t'201': 'Created',\n\t'202': 'Accepted',\n\t'203': 'Non-Authoritative Information',\n\t'204': 'No Content',\n\t'205': 'Reset Content',\n\t'206': 'Partial Content',\n\t'207': 'Multi-Status',\n\t// 3 重定向\n\t'300': 'Multiple Choices',\n\t'301': 'Moved Permanently',\n\t'302': 'Move Temporarily',\n\t'303': 'See Other',\n\t'304': 'Not Modified',\n\t'305': 'Use Proxy',\n\t'306': 'Switch Proxy',\n\t'307': 'Temporary Redirect',\n\t// 4 请求错误\n\t'400': 'Bad Request',\n\t'401': 'Unauthorized',\n\t'402': 'Payment Required',\n\t'403': 'Forbidden',\n\t'404': 'Not Found',\n\t'405': 'Method Not Allowed',\n\t'406': 'Not Acceptable',\n\t'407': 'Proxy Authentication Required',\n\t'408': 'Request Timeout',\n\t'409': 'Conflict',\n\t'410': 'Gone',\n\t'411': 'Length Required',\n\t'412': 'Precondition Failed',\n\t'413': 'Request Entity Too Large',\n\t'414': 'Request-URI Too Long',\n\t'415': 'Unsupported Media Type',\n\t'416': 'Requested Range Not Satisfiable',\n\t'417': 'Expectation Failed',\n\t'418': 'I\\'m a teapot',\n\t'421': 'Misdirected Request',\n\t'422': 'Unprocessable Entity',\n\t'423': 'Locked',\n\t'424': 'Failed Dependency',\n\t'425': 'Too Early',\n\t'426': 'Upgrade Required',\n\t'449': 'Retry With',\n\t'451': 'Unavailable For Legal Reasons',\n\t// 5 服务器错误\n\t'500': 'Internal Server Error',\n\t'501': 'Not Implemented',\n\t'502': 'Bad Gateway',\n\t'503': 'Service Unavailable',\n\t'504': 'Gateway Timeout',\n\t'505': 'HTTP Version Not Supported',\n\t'506': 'Variant Also Negotiates',\n\t'507': 'Insufficient Storage',\n\t'509': 'Bandwidth Limit Exceeded',\n\t'510': 'Not Extended',\n\t'600': 'Unparseable Response Headers',\n}\n\n/**\n  * 跳转登录页\n  * 携带当前页面路由，以期在登录页面完成登录后返回当前页面\n  */\nconst toLogin = () => {\n\trouter.replace({\n\t\tpath: '/login',\n\t\tquery: {\n\t\t\tredirect: router.currentRoute.fullPath\n\t\t}\n\t});\n}\n\n/**\n  * 请求失败后的错误统一处理\n  * @param {Number} status 请求失败的状态码\n  */\nconst baseErrorHandler = error => {\n\tconst { response, message } = error\n\t// 状态码判断\n\tswitch (response.status) {\n\t\t// 401: 未登录状态，跳转登录页\n\t\tcase 401:\n\t\t\ttoLogin();\n\t\t\tbreak;\n\n\t\t// 403 token过期\n\t\t// 清除token并跳转登录页\n\t\tcase 403:\n\t\t\terror.message = '登录过期，请重新登录';\n\t\t\tlocalStorage.removeItem('token');\n\t\t\tstore.commit('loginSuccess', null);\n\t\t\tsetTimeout(() => {\n\t\t\t\ttoLogin();\n\t\t\t}, 1000);\n\t\t\tbreak;\n\n\t\t// 404请求不存在\n\t\tcase 404:\n\t\t\terror.message = '请求的资源不存在';\n\t\t\tbreak;\n\n\t\t// 500服务器内部错误\n\t\tcase 500:\n\t\t\terror.message = '服务器内部错误';\n\t\t\tbreak;\n\n\t\t// 502服务网关出错\n\t\tcase 502:\n\t\t\terror.message = '服务网关出错';\n\t\t\tbreak;\n\n\t\t// 504服务网关超时\n\t\tcase 504:\n\t\t\terror.message = '服务网关超时';\n\t\t\tbreak;\n\t}\n}\n\n// 默认配置\nconst defConfigs = configs\n\n// 全局拦截钩子\nconst interceptors = {\n\t// 请求前\n\tbeforeRequest(config) {\n\t\t// 登录流程控制中，根据本地是否存在token判断用户的登录情况\n\t\t// 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token\n\t\t// 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码\n\t\t// 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。\n\n\t\t/*\n\t\tconst token = store.state.token;\n\t\ttoken && (config.headers.Authorization = token);\n\t\t*/\n\t\treturn config;\n\t},\n\t// 请求出错\n\trequestError(error) {\n\t\treturn Promise.reject(error)\n\t},\n\tresponse(res) {\n\t\treturn res.status >= 200 && res.status < 300 ? Promise.resolve(res) : Promise.reject(res)\n\t},\n\tresponseError(error) {\n\t\tconst { response } = error;\n\t\tif (response) {\n\t\t\t// 响应码不在2xx的范围\n\t\t\tbaseErrorHandler(error);\n\t\t} else {\n\t\t\t// 处理断网的情况\n\t\t\t// eg:请求超时或断网时，更新state的network状态\n\t\t\t// network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏\n\t\t\t// 关于断网组件中的刷新重新获取数据，会在断网组件中说明\n\t\t\t// store.commit('changeNetwork', false);\n\t\t}\n\t\treturn Promise.reject(error);\n\t}\n}\n\n/**\n  * 创建请求实例\n  * @param {Object} configs 全局配置\n  */\nconst createInstance = (handler, configs) => {\n\t// 创建axios实例\n\tvar instance = handler.create(configs);\n\n\t// 设置post请求头\n\tinstance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n\n\t/**\n\t\t* 请求拦截器\n\t\t* 每次请求前，如果存在token则在请求头中携带token\n\t\t*/\n\tinstance.interceptors.request.use(\n\t\t// 请求成功\n\t\tinterceptors.beforeRequest,\n\t\t// 请求失败\n\t\tinterceptors.requestError\n\t)\n\n\t/**\n\t\t* 响应拦截器\n\t\t*/\n\tinstance.interceptors.response.use(\n\t\t// 响应成功\n\t\tinterceptors.response,\n\t\t// 响应失败\n\t\tinterceptors.responseError\n\t);\n\n\treturn instance\n}\n\n/**\n * 请求处理器\n * @param {Object} handler 处理器\n * @param {String} method 方法\n * @param {Object} options 选项\n * \n * 1.创建请求实例\n * 2.整合请求配置、数据\n * 3.处理响应\n */\nconst requestHandler = (handler, method, options) => {\n\tlet { url, params, data, headers, validator, filter, errorMessage, successMessage } = options\n\n\treturn new Promise((resolve, reject) => {\n\t\thandler(\n\t\t\t{\n\t\t\t\turl,\n\t\t\t\tmethod,\n\t\t\t\tparams,\n\t\t\t\tdata,\n\t\t\t\theaders\n\t\t\t}\n\t\t).then(res => {\n\t\t\tconst valid = validator && validator(res)\n\t\t\tif (valid === undefined || valid === true) {\n\t\t\t\tresolve(successHandler(res, filter, successMessage))\n\t\t\t} else {\n\t\t\t\treject(errorHandler(res, res, errorMessage))\n\t\t\t}\n\t\t})\n\t\t\t.catch(err => {\n\t\t\t\treject(errorHandler(null, err, errorMessage))\n\t\t\t})\n\t})\n}\n\n/**\n * 响应处理器\n * @param {Object} response 正常响应\n * @param {Function} callback 回调函数\n * @param {Object} error 报错响应\n */\nconst successHandler = (response, filter, successMessage) => {\n\tlet { data } = response\n\tlet presetMessage = successMessage && successMessage(response);\n\n\treturn {\n\t\tresult: filter && filter(data) || data, // 内容\n\t\tpage: data && data.page || null, // 分页\n\t\tresponse, // 正常响应\n\t\t// 提示信息\n\t\tpresetMessage,\n\t\tmessage(msg) {\n\t\t\tMessage.success(msg || presetMessage || baseMessage)\n\t\t},\n\t\tnotify(msg) {\n\t\t\tNotification({\n\t\t\t\ttype: 'success',\n\t\t\t\ttitle: '提示',\n\t\t\t\tmessage: msg || presetMessage || baseMessage\n\t\t\t})\n\t\t}\n\t}\n}\n\n/**\n * 响应处理器\n * @param {Object} response 正常响应\n * @param {Object} error 报错响应\n * @param {Function} callback 回调函数\n * @param {Function} filter 过滤器\n */\nconst errorHandler = (response, error, errorMessage) => {\n\tlet baseMessage = error && error.message;\n\tlet presetMessage = errorMessage && errorMessage(error);\n\treturn {\n\t\tresult: null, // 内容\n\t\tpage: null, // 分页\n\t\tresponse, // 响应信息\n\t\terror, // 报错响应\n\t\t// 提示信息\n\t\tbaseMessage,\n\t\tpresetMessage,\n\t\tmessage(msg) {\n\t\t\tMessage.error(msg || presetMessage || baseMessage)\n\t\t},\n\t\tnotify(msg = {}) {\n\t\t\tNotification({\n\t\t\t\ttype: 'error',\n\t\t\t\ttitle: msg.title || '服务出错了，请联系管理员，错误信息如下：',\n\t\t\t\tmessage: msg.message || presetMessage || baseMessage\n\t\t\t})\n\t\t}\n\t}\n}\n\n/**\n\t* 创建请求方法对象\n\t* @params {handler} 处理器\n\t*/\nconst createRequsetMethods = handler => {\n\t// 请求方法列表\n\tconst methods = ['get', 'post', 'put', 'delete', 'head', 'patch'];\n\n\treturn methods.reduce((total, x) => {\n\t\ttotal[x] = options => requestHandler(handler, x, options)\n\t\treturn total\n\t}, {})\n}\n\n/**\n * 默认实例\n */\nconst defInstance = createInstance(axios, defConfigs);\n\n/**\n * 对外接口对象\n */\nconst Interface = {\n\t/**\n\t * 默认请求方法\n\t */\n\t...createRequsetMethods(defInstance),\n\n\t/**\n\t * 使用创建方法生成实可调用例，可传入自定义配置\n\t * @param {Object} configs 配置项\n\t * @demo \n\t * let $api = request.create({....})\n\t * $api.get({...})\n\t */\n\tcreate(configs) {\n\t\tconst instance = createInstance(axios, {\n\t\t\t...defConfigs,\n\t\t\t...configs\n\t\t});\n\n\t\t/**\n\t\t\t* 封装接口对象\n\t\t\t* options来自调用实例的选项\n\t\t\t* req来自调用实例的原始选项\n\t\t\t*/\n\t\treturn createRequsetMethods(instance)\n\t}\n}\n\nexport default Interface\n")],-1);function v(t,e){const n=Object(r["U"])("code-viewer");return Object(r["L"])(),Object(r["n"])("section",s,[a,Object(r["r"])(n,null,{default:Object(r["jb"])(()=>[o]),_:1}),c,i,l,u,Object(r["r"])(n,null,{default:Object(r["jb"])(()=>[p]),_:1}),d,g,b,Object(r["r"])(n,null,{default:Object(r["jb"])(()=>[h]),_:1}),m,Object(r["r"])(n,null,{default:Object(r["jb"])(()=>[j]),_:1}),f,Object(r["r"])(n,null,{default:Object(r["jb"])(()=>[O]),_:1}),x,Object(r["r"])(n,null,{default:Object(r["jb"])(()=>[M]),_:1}),q,Object(r["r"])(n,null,{default:Object(r["jb"])(()=>[y]),_:1})])}var k=n("6b0d"),X=n.n(k);const R={},P=X()(R,[["render",v]]);e["default"]=P}}]);