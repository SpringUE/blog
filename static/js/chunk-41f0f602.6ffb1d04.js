(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-41f0f602"],{1488:function(e,t,n){e.exports=n.p+"static/img/webpack_require.424fb6e1.jpg"},"23c5":function(e,t,n){e.exports=n.p+"static/img/webpack_working.538c4af0.png"},7472:function(e,t,n){"use strict";n.r(t);var a=n("f2bf"),c=n("23c5"),l=n.n(c),o=n("874e"),r=n.n(o),d=n("1488"),s=n.n(d);const u={class:"blog-doc-component"},p=Object(a["createStaticVNode"])('<h1>Webpack打包原理浅析</h1><h2 id="jian-jie" tabindex="-1"><a class="header-anchor" href="#jian-jie">¶</a> 简介</h2><p>对于很多前端小伙伴来说，webpack绝对是不陌生的，但是如果想要较为深入地去理解其中的原理，其实并不简单。因此，本文就目前前端最为热门的打包工具webpack，对其作用、打包原理及优化进行一定程度的探讨，分析过程中有部分自己的见解，同时也引用了部分外部的资料，如有错误，欢迎指出。</p><h2 id="1-wei-he-shi-yong-webpack" tabindex="-1"><a class="header-anchor" href="#1-wei-he-shi-yong-webpack">¶</a> 1、为何使用Webpack？</h2><p>当出现一些新鲜事物的时候，我们总会去思考这个新鲜事物出现的必要性，webpack的出现也是一样，因此webpack出现之前，开发过程中实际存在着非常多的困难： 引用一些脚本来存放每个功能，加载太多脚本会导致网络瓶颈？ IIFE 使用方式可以将所有项目文件拼接在一起，但是却使构建结果的优化变得更加困难？ CommonJS 问世并引入了 require 机制，但浏览器不支持模块？等等... 因而就此看来，webpack的问世也变得顺其自然了，当然它也很好地解决了上面所存在得困难： a: 模块化开发，强大的构建优化能力（import，require） b: 预处理，方便使用多种格式资源（Less，Sass，ES6，TypeScrip等） c: 主流框架脚手架支持，大大加快开发效率（Vue，React，Angular） d: 良好以及众多的社区支持（资源丰富，降低学习成本）</p><h2 id="2-webpackshi-shi-me" tabindex="-1"><a class="header-anchor" href="#2-webpackshi-shi-me">¶</a> 2、Webpack是什么？</h2><p>对于webpack的定义其实可以归结为js模块打包器，在 webpack 中，一切皆是模块，一个文件就是一个模块(module)，它能够根据指定的入口（entry），通过模块间的依赖关系，递归地构建出一张依赖关系图（dependency graph）。由于webpack只理解 JavaScript 和 JSON 文件，过程中可以通过配置指定的加载器（loader）对相应文件进行转换，也可以通过配置指定的插件（plugins）对上下文进行优化输出（output）为代码块（chunk）如下图（引用的网图）：</p>',7),b=Object(a["createElementVNode"])("img",{src:l.a,alt:"webpack working"},null,-1),i=Object(a["createElementVNode"])("h2",{id:"3-webpack.config.jschang-yong-zhu-yao-he-xin-pei-zhi-gai-nian",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#3-webpack.config.jschang-yong-zhu-yao-he-xin-pei-zhi-gai-nian"},"¶"),Object(a["createTextVNode"])(" 3、webpack.config.js常用主要核心配置概念")],-1),m=Object(a["createElementVNode"])("p",null,"a: 模式mode 通过告诉webpack使用相应模式，存在两种配置方式 通过配置文件：",-1),j=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"module.exports = {\n  mode: 'production', // development\n}\n\n")],-1),O=Object(a["createElementVNode"])("p",null,"通过命令行传参：",-1),h=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"webpack --mode=production\n\n")],-1),g=Object(a["createElementVNode"])("p",null,"然后代码中：",-1),N=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"if(process.env.NODE_ENV === 'development'){\n//开发环境处理逻辑\n}else{\n//生产环境处理逻辑\n}\n\n")],-1),V=Object(a["createElementVNode"])("p",null,"b: 入口entry 单入口：",-1),w=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"module.exports = {\n    entry: './src/main.js',\n}\n\n")],-1),E=Object(a["createElementVNode"])("p",null,"多入口：",-1),k=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"module.exports = {\n  entry: {\n    foo: './src/main.js',\n    bar: './src/foo.js',\n    com: './src/bar.js'\n  }\n}\n\n")],-1),f=Object(a["createElementVNode"])("p",null,"c: 出口output 告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值是 ./dist: 单出口：",-1),x=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"const path = require('path')\nmodule.exports = {\n  output: {\n      filename: 'main.js',\n      path: path.resolve(__dirname, 'dist')\n  }\n}\n\n")],-1),_=Object(a["createElementVNode"])("p",null,"多出口：",-1),v=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"const path = require('path')\nmodule.exports = {\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  }\n}\n\n")],-1),y=Object(a["createElementVNode"])("p",null,"d: 模块module 在webpack中，一切皆是模块，而一个文件就是一个模块。 e: 加载器loader 由于webpack本身只能理解JavaScript语法，因此只能对js文件进行直接的文件合并、压缩处理。但是实际项目中会用到很多类型的文件，如 css、less、jpg、jsx、vue 等等类型的文件，webpack本身是处理不了它们的，这个时候就要借助于各种loader。 loader 的作用就是将各种类型的文件转换成 webpack 能够处理的模块，例如项目中使用了 less 语法，就需要使用 less-loader 去将其转译为 css，然后通过 css-loader 去加载 css 文件，处理后交给 style-loader，最后把资源路径写入到 html 中的 style 标签内生效。",-1),C=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"module: {\n    rules: [{\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader', 'less-loader']\n    }]\n},\n\n")],-1),q=Object(a["createElementVNode"])("p",null,"需要注意的是由于 loader 是从右往左执行的，一个 loader 处理完的结果会交给下一个 loader 继续处理，就像一条工厂流水线一样，所以加载器数组存在一定的次序。 此外特别需要知道的是，有一个非常重要的 loader，那就是 babel-loader，其可以将es6语法转换成能普遍被浏览器所执行的es5。 f: 插件plugin 插件是用来处理各种任务的，比如代码的压缩，打包优化，等等。比如自动生成 html 文件的插件",-1),P=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"const HtmlWebpackPlugin = require('html-webpack-plugin'); \nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin({\n        template: './src/index.html'\n    })\n  ]\n};\n\n")],-1),S=Object(a["createElementVNode"])("p",null,"g: 代码块chunk 代码块，一个chunk由多个模块组合而成，用于代码合并和分割。 h: 源代码映射source-map source map 是一种映射关系，当程序出问题时，我们想要从打包后的代码中去排查问题时比较困难的。这个时候我们就要借助于源代码去排查。其中包含有好几种配置方式：",-1),T=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"module.exports = {\n  devtool: 'source-map'，//inline-source-map, inline-cheap-source-map, inline-cheap-module-source-map, eval\n}\n\n")],-1),I=Object(a["createElementVNode"])("p",null,"source-map：打包后会生成 map 格式的文件，里面包含映射关系的代码 inline-source-map：打包后不会生成 map 格式的文件，包含映射关系的代码会放在打包后的代码中 inline-cheap-source-map：cheap有两种作用：一是将错误只定位到行，不定位到列。二是映射业务代码，不映射loader和第三方库等。会提升打包构建的速度。 inline-cheap-module-source-map：module会映射loader和第三方库 eval：用 eval 的方式生成映射关系代码，效率和性能最佳。但是当代码复杂时，提示信息可能不精确 因此实际开发中往往推荐以下两种配置方式 开发环境： devtool: 'cheap-module-eval-source-map', 生产环境 devtool: 'cheap-module-source-map',",-1),z=Object(a["createElementVNode"])("h2",{id:"4-da-bao-liu-cheng-ji-ben-yuan-li-qian-xi",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#4-da-bao-liu-cheng-ji-ben-yuan-li-qian-xi"},"¶"),Object(a["createTextVNode"])(" 4、打包流程基本原理浅析")],-1),B=Object(a["createElementVNode"])("p",null,"以下的原理解析是基于webpack4的自我理解，根据简单的demo目标打包生成物为切入口进行分析，进而去理解其内部执行流程，其大致工作流程如下图（引用的网图）所示：",-1),A=Object(a["createElementVNode"])("img",{src:r.a,alt:"webpack flow"},null,-1),H=Object(a["createElementVNode"])("p",null,"a: 打包后产物(简略部分)",-1),J=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"(function (modules) {\n    //内部执行流程\n    ...\n})({\n    //外部模块id对象\n    './main.js': (function (module, exports, __webpack_require__) {}),\n    './foo.js': (function (module, exports, __webpack_require__) {}),\n    ...\n})\n\n")],-1),W=Object(a["createElementVNode"])("p",null,"webpack 打包完输出的 bundle.js 大致就是上面这个架子。可以看出它本质就是一个自执行的函数，参数是 一个Object 对象，而对象的key 就是我们项目中的各个模块的js 文件名称。value 是一个 function，模块中的代码都会被解析后放在这个 function 内。 这些 function 会接收 module 和 exports 做为参数，这也是为什么我们在模块中使用 CommonJs 语法（也就是 modules.exports = {} 或者 直接 exports = {}），浏览器能够识别的原因。我们在模块的最后其实使用 module.exports = {}，其实就是把模块的内容放进了 exports 对象里而已。 b: 传参数组（模块数组）的形成 那上面这个传递给匿名函数的数组又是怎么形成的呢？过程大致如下： webpack 中有这么一个 Complier 类，它首先会读取 webpack.config.js 中的内容 然后通过 @babel/parse，从入口文件 entry 来构建一颗抽象语法树 AST 然后通过 @babel/traverse，根据抽象语法树得出入口文件的依赖模块 然后通过 @babel/core 和 @babel/preset-env，根据抽象语法树解析出入口文件的代码。这一步已经把 ES6 或更高版本的 js 转换了，然后循环递归入口文件的依赖，构建出一张依赖关系图这就是我们上面用到的数组了。 c: 匿名函数内部",-1),M=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},'var installedModules = {};\nfunction __webpack_require__(moduleId) {\n    if(installedModules[moduleId]) {\n        return installedModules[moduleId].exports;\n    }\n    var module = installedModules[moduleId] = {\n        i: moduleId,\n        l: false,\n        exports: {}\n    };       \n    modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);\n    module.l = true;\n    return module.exports;\n}\nreturn __webpack_require__(__webpack_require__.s = "./src/main.js");\n\n')],-1),$=Object(a["createElementVNode"])("p",null,[Object(a["createTextVNode"])("可以看到自执行函数里面定义了一个 "),Object(a["createElementVNode"])("strong",null,"webpack_require"),Object(a["createTextVNode"])(" 函数，是用来装载模块的。它的入参是模块的唯一标识，从a中我们可以看到这个唯一标识就是模块的文件名称。 其中装载后的变量会放在变量 installedModules 里面，防止同一模块重复装载。 而什么是装载？装载就是执行传进来的 modules 中的一个个函数，也就是会执行我们所写的业务模块里面的代码，把 exports 传进去，然后我们会这样 module.exports = {...}，把内容给放进去。简而言之，装载就是把模块代码装进 exports 对象。"),Object(a["createElementVNode"])("strong",null,"webpack_require"),Object(a["createTextVNode"])(" 函数最终会返回这个 exports。 我们模块中的依赖也会调用这个 "),Object(a["createElementVNode"])("strong",null,"webpack_require"),Object(a["createTextVNode"])("，比如 main.js 引入了 foo.js，那么 main 函数内部会有这么一句 const foo = "),Object(a["createElementVNode"])("strong",null,"webpack_require"),Object(a["createTextVNode"])('(/*! ./foo */ "./foo.js"); 这样我们就可以在 main 中获取并使用到 foo 所提供的功能了（其实就是在用 foo.js 中最后赋值的那个 exports） d：流程细分图（引用的网图）如下：')],-1),D=Object(a["createElementVNode"])("img",{src:s.a,alt:"webpack require"},null,-1),F=Object(a["createElementVNode"])("p",null,[Object(a["createTextVNode"])("e：更详细通俗易懂的demo可以查阅"),Object(a["createElementVNode"])("a",{href:"https://blog.csdn.net/haodawang/article/details/77126686"},"此文章")],-1),R=Object(a["createElementVNode"])("h2",{id:"5-chang-jian-you-hua-gou-jian",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#5-chang-jian-you-hua-gou-jian"},"¶"),Object(a["createTextVNode"])(" 5、常见优化构建")],-1),L=Object(a["createElementVNode"])("p",null,"a: 优化loader配置 上面章节我们可以知道loader作用是对相应文件进行转换，所以我们可以考虑通过减少loader作用范围，大大缩短构建时间。例如Babel，由于Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。因此我们直接指定哪些文件不通过loader处理,或者指定哪些文件通过loader处理：",-1),G=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"const path = require('path')\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        // js 文件才使用 babel\n        test: /\\.js$/,\n        use: ['babel-loader'],\n        // 只处理src文件夹下面的文件\n        include: path.resolve('src'),\n        // 不处理node_modules下面的文件，node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。\n        exclude: /node_modules/\n      }\n    ]\n  }\n}\n\n")],-1),K=Object(a["createElementVNode"])("p",null,"另外，对于babel-loader，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间。",-1),Q=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"module.exports = {\n  loader: 'babel-loader?cacheDirectory=true'\n}\n")],-1),U=Object(a["createElementVNode"])("p",null,"b: 使用多线程处理打包 由于node是单线程运行的，所以 webpack 在打包的过程中也是单线程的，特别是在执行 loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。那么我们可以使用一些方法将 loader 的同步执行转换为并行，这样就能充分利用系统资源来提高打包速度了。 例如happypack，如其包名，快乐的打包。就是能够让Webpack把打包任务分解给多个子线程去并发的执行，子线程处理完后再把结果发送给主线程：",-1),X=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"const HappyPack = require('happypack');\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        //把 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例\n        use: ['happypack/loader?id=babel'],\n        exclude: path.resolve(__dirname, 'node_modules'),\n      },\n      {\n        test: /\\.css$/,\n        // 把 .css 文件的处理转交给 id 为 css 的 HappyPack 实例\n        use: ['happypack/loader?id=css']\n      }\n    ]\n  },\n  plugins: [\n    new HappyPack({\n      id: 'js', //ID是标识符的意思，ID用来代理当前的happypack是用来处理一类特定的文件的\n      threads: 2, //你要开启多少个子进程去处理这一类型的文件\n      loaders: [ 'babel-loader' ]\n    }),\n    new HappyPack({\n      id: 'css',\n      threads: 2,\n      loaders: [ 'style-loader', 'css-loader' ]\n    })\n  ],\n}\n")],-1),Y=Object(a["createElementVNode"])("p",null,"c: module.noParse 属性 module.noParse 属性，可以用于配置那些模块文件的内容不需要进行解析（即无依赖） 的第三方大型类库（例如jquery,lodash）等，使用该属性让 Webpack不扫描该文件，以提高整体的构建速度。",-1),Z=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"module.exports = {\n    module: {\n      noParse: /jquery|lodash/, // 正则\n      noParse: function(content) {\n        return /jquery|lodash/.test(content)\n      }\n    }\n}\n")],-1),ee=Object(a["createElementVNode"])("p",null,"d: 打包文件分析工具 webpack-bundle-analyzer插件的功能是可以生成代码分析报告，帮助提升代码质量和网站性能。",-1),te=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin\nmodule.exports={\n  plugins: [\n     new BundleAnalyzerPlugin({\n        generateStatsFile: true, // 是否生成stats.json文件\n     })  \n  ]\n}\n")],-1),ne=Object(a["createElementVNode"])("p",null,"e: 对图片进行压缩和优化 image-webpack-loader这个loder可以帮助我们对打包后的图片进行压缩和优化，例如降低图片分辨率，压缩图片体积等。",-1),ae=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"module.exports ={\n    module: {\n        rules: [\n            {\n              test: /\\.(png|gif|jpe?g|svg)$/i,\n              exclude:[path.resolve(process.cwd(), 'src/assets/css')],\n              use: [\n                {\n                   loader: 'url-loader',\n                   options: {\n                   limit: 1024,// 图片限制\n                   name: '[hash:8].[ext]',\n                   useRelativePath: false,\n                   outputPath: function(fileName){\n                   return 'assets/images/'+fileName\n                    }\n                }\n            },\n            {\n              loader:'image-webpack-loader'\n            }\n        ]\n    }\n};\n")],-1),ce=Object(a["createElementVNode"])("p",null,"f： 删除无用的CSS样式 久远且疏于维护的项目可能会存在一些CSS样式被迭代废弃，可以将其去除掉，此时就可以使用purgecss-webpack-plugin插件，该插件可以去除未使用的CSS，一般与 glob、glob-all 一起配合使用。 注意：此插件必须和CSS代码抽离插件mini-css-extract-plugin配合使用。",-1),le=Object(a["createElementVNode"])("pre",null,[Object(a["createElementVNode"])("code",{class:"language-javascript"},"const glob = require('glob');\nconst PurgecssPlugin = require('purgecss-webpack-plugin');\nmodule.exports ={\n    plugins: [\n        // 需要配合mini-css-extract-plugin插件\n        new PurgecssPlugin({\n            paths: glob.sync(`${path.join(__dirname, 'src')}/**/*`, \n                  {nodir: true}), // 不匹配目录，只匹配文件\n            })\n        }),\n    ]\n};\n")],-1),oe=Object(a["createElementVNode"])("h2",{id:"can-kao",tabindex:"-1"},[Object(a["createElementVNode"])("a",{class:"header-anchor",href:"#can-kao"},"¶"),Object(a["createTextVNode"])(" 参考：")],-1),re=Object(a["createElementVNode"])("p",null,[Object(a["createElementVNode"])("a",{href:"https://webpack.docschina.org/concepts/"},"https://webpack.docschina.org/concepts/"),Object(a["createElementVNode"])("br"),Object(a["createElementVNode"])("a",{href:"https://survivejs.com/webpack/developing/getting-started/"},"https://survivejs.com/webpack/developing/getting-started/")],-1);function de(e,t){const n=Object(a["resolveComponent"])("image-viewer"),c=Object(a["resolveComponent"])("code-viewer");return Object(a["openBlock"])(),Object(a["createElementBlock"])("section",u,[p,Object(a["createElementVNode"])("p",null,[Object(a["createVNode"])(n,{url:"../../img/webpack_working.png"},{default:Object(a["withCtx"])(()=>[b]),_:1})]),i,m,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[j]),_:1}),O,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[h]),_:1}),g,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[N]),_:1}),V,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[w]),_:1}),E,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[k]),_:1}),f,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[x]),_:1}),_,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[v]),_:1}),y,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[C]),_:1}),q,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[P]),_:1}),S,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[T]),_:1}),I,z,B,Object(a["createElementVNode"])("p",null,[Object(a["createVNode"])(n,{url:"../../img/webpack_flow.png"},{default:Object(a["withCtx"])(()=>[A]),_:1})]),H,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[J]),_:1}),W,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[M]),_:1}),$,Object(a["createElementVNode"])("p",null,[Object(a["createVNode"])(n,{url:"../../img/webpack_require.jpg"},{default:Object(a["withCtx"])(()=>[D]),_:1})]),F,R,L,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[G]),_:1}),K,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[Q]),_:1}),U,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[X]),_:1}),Y,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[Z]),_:1}),ee,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[te]),_:1}),ne,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[ae]),_:1}),ce,Object(a["createVNode"])(c,null,{default:Object(a["withCtx"])(()=>[le]),_:1}),oe,re])}var se=n("b9a6"),ue=n.n(se);const pe={},be=ue()(pe,[["render",de]]);t["default"]=be},"874e":function(e,t,n){e.exports=n.p+"static/img/webpack_flow.562a9d07.png"},b9a6:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=(e,t)=>{const n=e.__vccOpts||e;for(const[a,c]of t)n[a]=c;return n}}}]);